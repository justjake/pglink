// Code generated by generate.go; DO NOT EDIT.

package pgwire

import (
	"fmt"
	"io"

	"github.com/jackc/pgx/v5/pgproto3"
)

// ClientSimpleQuery is implemented by all Client SimpleQuery message wrapper types.
type ClientSimpleQuery interface {
	SimpleQuery()
	PgwireMessage() pgproto3.Message
	Client() pgproto3.FrontendMessage
	Raw() RawBody
}

// Compile-time checks that all wrapper types implement the interface.
var (
	_ ClientSimpleQuery = ClientSimpleQueryQuery{}
	_ ClientSimpleQuery = ClientSimpleQueryFunctionCall{}
)

// Simple query.
// Destroys unnamed prepared statement & portal.
type ClientSimpleQueryQuery LazyClient[*pgproto3.Query]

func (ClientSimpleQueryQuery) SimpleQuery() {}
func (t ClientSimpleQueryQuery) PgwireMessage() pgproto3.Message {
	return (*LazyClient[*pgproto3.Query])(&t).Parse()
}
func (t ClientSimpleQueryQuery) Client() pgproto3.FrontendMessage {
	return (*LazyClient[*pgproto3.Query])(&t).Parse()
}
func (m ClientSimpleQueryQuery) Raw() RawBody { return LazyClient[*pgproto3.Query](m).Raw() }
func (m *ClientSimpleQueryQuery) Parse() *pgproto3.Query {
	return (*LazyClient[*pgproto3.Query])(m).Parse()
}
func (m ClientSimpleQueryQuery) IsParsed() bool { return LazyClient[*pgproto3.Query](m).IsParsed() }
func (m ClientSimpleQueryQuery) Body() []byte   { return LazyClient[*pgproto3.Query](m).Body() }
func (m *ClientSimpleQueryQuery) WriteTo(w io.Writer) (int64, error) {
	return (*LazyClient[*pgproto3.Query])(m).WriteTo(w)
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ClientSimpleQueryQuery) Retain() ClientSimpleQueryQuery {
	src, parsed, isParsed := (*LazyClient[*pgproto3.Query])(&m).retainFields()
	return ClientSimpleQueryQuery{source: src, parsed: parsed, isParsed: isParsed}
}

// Call a function; seems to work like a simple query? Or maybe it works with both modes?
type ClientSimpleQueryFunctionCall LazyClient[*pgproto3.FunctionCall]

func (ClientSimpleQueryFunctionCall) SimpleQuery() {}
func (t ClientSimpleQueryFunctionCall) PgwireMessage() pgproto3.Message {
	return (*LazyClient[*pgproto3.FunctionCall])(&t).Parse()
}
func (t ClientSimpleQueryFunctionCall) Client() pgproto3.FrontendMessage {
	return (*LazyClient[*pgproto3.FunctionCall])(&t).Parse()
}
func (m ClientSimpleQueryFunctionCall) Raw() RawBody {
	return LazyClient[*pgproto3.FunctionCall](m).Raw()
}
func (m *ClientSimpleQueryFunctionCall) Parse() *pgproto3.FunctionCall {
	return (*LazyClient[*pgproto3.FunctionCall])(m).Parse()
}
func (m ClientSimpleQueryFunctionCall) IsParsed() bool {
	return LazyClient[*pgproto3.FunctionCall](m).IsParsed()
}
func (m ClientSimpleQueryFunctionCall) Body() []byte {
	return LazyClient[*pgproto3.FunctionCall](m).Body()
}
func (m *ClientSimpleQueryFunctionCall) WriteTo(w io.Writer) (int64, error) {
	return (*LazyClient[*pgproto3.FunctionCall])(m).WriteTo(w)
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ClientSimpleQueryFunctionCall) Retain() ClientSimpleQueryFunctionCall {
	src, parsed, isParsed := (*LazyClient[*pgproto3.FunctionCall])(&m).retainFields()
	return ClientSimpleQueryFunctionCall{source: src, parsed: parsed, isParsed: isParsed}
}

// ToClientSimpleQuery converts a pgproto3.FrontendMessage to a ClientSimpleQuery if it matches one of the known types.
func ToClientSimpleQuery(msg pgproto3.FrontendMessage) (ClientSimpleQuery, bool) {
	switch m := msg.(type) {
	case *pgproto3.Query:
		return ClientSimpleQueryQuery(NewLazyClientFromParsed(m)), true
	case *pgproto3.FunctionCall:
		return ClientSimpleQueryFunctionCall(NewLazyClientFromParsed(m)), true
	}
	return nil, false
}

// ClientSimpleQueryHandlers provides type-safe handlers for each ClientSimpleQuery variant.
type ClientSimpleQueryHandlers[T any] struct {
	Query        func(msg ClientSimpleQueryQuery) (T, error)
	FunctionCall func(msg ClientSimpleQueryFunctionCall) (T, error)
}

// HandleDefault dispatches to the appropriate handler, or calls defaultHandler if the handler is nil.
func (h ClientSimpleQueryHandlers[T]) HandleDefault(msg ClientSimpleQuery, defaultHandler func(msg ClientSimpleQuery) (T, error)) (r T, err error) {
	switch msg := msg.(type) {
	case ClientSimpleQueryQuery:
		if h.Query != nil {
			return h.Query(msg)
		} else {
			return defaultHandler(msg)
		}
	case ClientSimpleQueryFunctionCall:
		if h.FunctionCall != nil {
			return h.FunctionCall(msg)
		} else {
			return defaultHandler(msg)
		}
	}
	err = fmt.Errorf("unknown client simplequery message: %T", msg)
	return
}

// Handle dispatches to the appropriate handler, or panics if the handler is nil.
func (h ClientSimpleQueryHandlers[T]) Handle(msg ClientSimpleQuery) (T, error) {
	return h.HandleDefault(msg, func(msg ClientSimpleQuery) (T, error) {
		panic(fmt.Sprintf("no handler defined for client simplequery message: %T", msg))
	})
}
