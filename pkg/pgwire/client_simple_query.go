// Code generated by generate.go; DO NOT EDIT.

package pgwire

import (
	"github.com/jackc/pgx/v5/pgproto3"
)

// ClientSimpleQuery is implemented by all Client SimpleQuery message wrapper types.
type ClientSimpleQuery interface {
	SimpleQuery()
	PgwireMessage() pgproto3.Message
	Client() pgproto3.FrontendMessage
}

// Compile-time checks that all wrapper types implement the interface.
var (
	_ ClientSimpleQuery = ClientSimpleQueryQuery{}
	_ ClientSimpleQuery = ClientSimpleQueryFunctionCall{}
)

// Simple query.
// Destroys unnamed prepared statement & portal.
type ClientSimpleQueryQuery FromClient[*pgproto3.Query]

func (ClientSimpleQueryQuery) SimpleQuery()                       {}
func (t ClientSimpleQueryQuery) PgwireMessage() pgproto3.Message  { return t.T }
func (t ClientSimpleQueryQuery) Client() pgproto3.FrontendMessage { return t.T }

// Call a function; seems to work like a simple query? Or maybe it works with both modes?
type ClientSimpleQueryFunctionCall FromClient[*pgproto3.FunctionCall]

func (ClientSimpleQueryFunctionCall) SimpleQuery()                       {}
func (t ClientSimpleQueryFunctionCall) PgwireMessage() pgproto3.Message  { return t.T }
func (t ClientSimpleQueryFunctionCall) Client() pgproto3.FrontendMessage { return t.T }

// ToClientSimpleQuery converts a pgproto3.FrontendMessage to a ClientSimpleQuery if it matches one of the known types.
func ToClientSimpleQuery(msg pgproto3.FrontendMessage) (ClientSimpleQuery, bool) {
	switch m := msg.(type) {
	case *pgproto3.Query:
		return ClientSimpleQueryQuery{m}, true
	case *pgproto3.FunctionCall:
		return ClientSimpleQueryFunctionCall{m}, true
	}
	return nil, false
}
