// Code generated by generate.go; DO NOT EDIT.

package pgwire

import (
	"fmt"

	"github.com/jackc/pgx/v5/pgproto3"
)

// ClientExtendedQuery is implemented by all Client ExtendedQuery message wrapper types.
type ClientExtendedQuery interface {
	ExtendedQuery()
	PgwireMessage() pgproto3.Message
	Client() pgproto3.FrontendMessage
}

// Compile-time checks that all wrapper types implement the interface.
var (
	_ ClientExtendedQuery = (*ClientExtendedQueryParse)(nil)
	_ ClientExtendedQuery = (*ClientExtendedQueryBind)(nil)
	_ ClientExtendedQuery = (*ClientExtendedQueryExecute)(nil)
	_ ClientExtendedQuery = (*ClientExtendedQuerySync)(nil)
	_ ClientExtendedQuery = (*ClientExtendedQueryDescribe)(nil)
	_ ClientExtendedQuery = (*ClientExtendedQueryClose)(nil)
	_ ClientExtendedQuery = (*ClientExtendedQueryFlush)(nil)
)

// Extended Query 1: parse text into a prepared statement.
type ClientExtendedQueryParse FromClient[*pgproto3.Parse]

func (*ClientExtendedQueryParse) ExtendedQuery()                     {}
func (t *ClientExtendedQueryParse) PgwireMessage() pgproto3.Message  { return t.Parse() }
func (t *ClientExtendedQueryParse) Client() pgproto3.FrontendMessage { return t.Parse() }
func (m *ClientExtendedQueryParse) Parse() *pgproto3.Parse {
	return (*FromClient[*pgproto3.Parse])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ClientExtendedQueryParse) Retain() ClientExtendedQueryParse {
	src, parsed, isParsed := (*FromClient[*pgproto3.Parse])(&m).retainFields()
	return ClientExtendedQueryParse{source: src, parsed: parsed, isParsed: isParsed}
}

// Extended Query 2: Bind parameters to a prepared statement.
type ClientExtendedQueryBind FromClient[*pgproto3.Bind]

func (*ClientExtendedQueryBind) ExtendedQuery()                     {}
func (t *ClientExtendedQueryBind) PgwireMessage() pgproto3.Message  { return t.Parse() }
func (t *ClientExtendedQueryBind) Client() pgproto3.FrontendMessage { return t.Parse() }
func (m *ClientExtendedQueryBind) Parse() *pgproto3.Bind {
	return (*FromClient[*pgproto3.Bind])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ClientExtendedQueryBind) Retain() ClientExtendedQueryBind {
	src, parsed, isParsed := (*FromClient[*pgproto3.Bind])(&m).retainFields()
	return ClientExtendedQueryBind{source: src, parsed: parsed, isParsed: isParsed}
}

// Extended Query 3: Execute a prepared statement, requesting N or all rows.
// May need to be called again if server replies PortalSuspended.
// Execute phase is always terminated by the appearance of exactly one of
// these messages:
// - PortalSuspended: execute ended before completion, call Execute again.
// - CommandComplete: success
// - ErrorResponse: failure
// - EmptyQueryResponse: the portal was created from an empty query string
type ClientExtendedQueryExecute FromClient[*pgproto3.Execute]

func (*ClientExtendedQueryExecute) ExtendedQuery()                     {}
func (t *ClientExtendedQueryExecute) PgwireMessage() pgproto3.Message  { return t.Parse() }
func (t *ClientExtendedQueryExecute) Client() pgproto3.FrontendMessage { return t.Parse() }
func (m *ClientExtendedQueryExecute) Parse() *pgproto3.Execute {
	return (*FromClient[*pgproto3.Execute])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ClientExtendedQueryExecute) Retain() ClientExtendedQueryExecute {
	src, parsed, isParsed := (*FromClient[*pgproto3.Execute])(&m).retainFields()
	return ClientExtendedQueryExecute{source: src, parsed: parsed, isParsed: isParsed}
}

// Extended Query 4: Command pipeline complete.
//
// Causes the backend to close the current transaction if it's not inside a
// BEGIN/COMMIT transaction block ("close" meaning to commit if no error, or
// roll back if error).
// then, a ReadyForQuery response is issued.
//
// The purpose of Sync is to provide a resynchronization point for error
// recovery. When an error is detected while processing any extended-query
// message, the backend issues ErrorResponse, then reads and discards
// messages until a Sync is reached, then issues ReadyForQuery and returns
// to normal message processing. (But note that no skipping occurs if an
// error is detected while processing Sync â€” this ensures that there is
// one and only one ReadyForQuery sent for each Sync.)
// In addition to these fundamental, required operations, there are several
// optional operations that can be used with extended-query protocol.
type ClientExtendedQuerySync FromClient[*pgproto3.Sync]

func (*ClientExtendedQuerySync) ExtendedQuery()                     {}
func (t *ClientExtendedQuerySync) PgwireMessage() pgproto3.Message  { return t.Parse() }
func (t *ClientExtendedQuerySync) Client() pgproto3.FrontendMessage { return t.Parse() }
func (m *ClientExtendedQuerySync) Parse() *pgproto3.Sync {
	return (*FromClient[*pgproto3.Sync])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ClientExtendedQuerySync) Retain() ClientExtendedQuerySync {
	src, parsed, isParsed := (*FromClient[*pgproto3.Sync])(&m).retainFields()
	return ClientExtendedQuerySync{source: src, parsed: parsed, isParsed: isParsed}
}

// Extended Query tool: Describe prepared statement or portal.
//
// The Describe message (portal variant) specifies the name of an existing
// portal (or an empty string for the unnamed portal). The response is a
// RowDescription message describing the rows that will be returned by
// executing the portal; or a NoData message if the portal does not
// contain a query that will return rows; or ErrorResponse if there is no
// such portal.
//
// The Describe message (statement variant) specifies the name of an
// existing prepared statement (or an empty string for the unnamed
// prepared statement). The response is a ParameterDescription message
// describing the parameters needed by the statement, followed by a
// RowDescription message describing the rows that will be returned when
// the statement is eventually executed (or a NoData message if the
// statement will not return rows). ErrorResponse is issued if there is no
// such prepared statement. Note that since Bind has not yet been issued,
// the formats to be used for returned columns are not yet known to the
// backend; the format code fields in the RowDescription message will be
// zeroes in this case.
type ClientExtendedQueryDescribe FromClient[*pgproto3.Describe]

func (*ClientExtendedQueryDescribe) ExtendedQuery()                     {}
func (t *ClientExtendedQueryDescribe) PgwireMessage() pgproto3.Message  { return t.Parse() }
func (t *ClientExtendedQueryDescribe) Client() pgproto3.FrontendMessage { return t.Parse() }
func (m *ClientExtendedQueryDescribe) Parse() *pgproto3.Describe {
	return (*FromClient[*pgproto3.Describe])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ClientExtendedQueryDescribe) Retain() ClientExtendedQueryDescribe {
	src, parsed, isParsed := (*FromClient[*pgproto3.Describe])(&m).retainFields()
	return ClientExtendedQueryDescribe{source: src, parsed: parsed, isParsed: isParsed}
}

// Close prepared statement/portal.
// Note that closing a prepared statement implicitly closes any open
// portals that were constructed from that statement.
type ClientExtendedQueryClose FromClient[*pgproto3.Close]

func (*ClientExtendedQueryClose) ExtendedQuery()                     {}
func (t *ClientExtendedQueryClose) PgwireMessage() pgproto3.Message  { return t.Parse() }
func (t *ClientExtendedQueryClose) Client() pgproto3.FrontendMessage { return t.Parse() }
func (m *ClientExtendedQueryClose) Parse() *pgproto3.Close {
	return (*FromClient[*pgproto3.Close])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ClientExtendedQueryClose) Retain() ClientExtendedQueryClose {
	src, parsed, isParsed := (*FromClient[*pgproto3.Close])(&m).retainFields()
	return ClientExtendedQueryClose{source: src, parsed: parsed, isParsed: isParsed}
}

// The Flush message does not cause any specific output to be generated,
// but forces the backend to deliver any data pending in its output
// buffers. A Flush must be sent after any extended-query command except
// Sync, if the frontend wishes to examine the results of that command
// before issuing more commands. Without Flush, messages returned by the
// backend will be combined into the minimum possible number of packets to
// minimize network overhead.
type ClientExtendedQueryFlush FromClient[*pgproto3.Flush]

func (*ClientExtendedQueryFlush) ExtendedQuery()                     {}
func (t *ClientExtendedQueryFlush) PgwireMessage() pgproto3.Message  { return t.Parse() }
func (t *ClientExtendedQueryFlush) Client() pgproto3.FrontendMessage { return t.Parse() }
func (m *ClientExtendedQueryFlush) Parse() *pgproto3.Flush {
	return (*FromClient[*pgproto3.Flush])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ClientExtendedQueryFlush) Retain() ClientExtendedQueryFlush {
	src, parsed, isParsed := (*FromClient[*pgproto3.Flush])(&m).retainFields()
	return ClientExtendedQueryFlush{source: src, parsed: parsed, isParsed: isParsed}
}

// ToClientExtendedQuery converts a pgproto3.FrontendMessage to a ClientExtendedQuery if it matches one of the known types.
// Note: This allocates. For zero-allocation iteration, use Cursor.AsClient().
func ToClientExtendedQuery(msg pgproto3.FrontendMessage) (ClientExtendedQuery, bool) {
	switch m := msg.(type) {
	case *pgproto3.Parse:
		return (*ClientExtendedQueryParse)(ClientParsed(m)), true
	case *pgproto3.Bind:
		return (*ClientExtendedQueryBind)(ClientParsed(m)), true
	case *pgproto3.Execute:
		return (*ClientExtendedQueryExecute)(ClientParsed(m)), true
	case *pgproto3.Sync:
		return (*ClientExtendedQuerySync)(ClientParsed(m)), true
	case *pgproto3.Describe:
		return (*ClientExtendedQueryDescribe)(ClientParsed(m)), true
	case *pgproto3.Close:
		return (*ClientExtendedQueryClose)(ClientParsed(m)), true
	case *pgproto3.Flush:
		return (*ClientExtendedQueryFlush)(ClientParsed(m)), true
	}
	return nil, false
}

// ClientExtendedQueryHandlers provides type-safe handlers for each ClientExtendedQuery variant.
type ClientExtendedQueryHandlers[T any] struct {
	Parse    func(msg *ClientExtendedQueryParse) (T, error)
	Bind     func(msg *ClientExtendedQueryBind) (T, error)
	Execute  func(msg *ClientExtendedQueryExecute) (T, error)
	Sync     func(msg *ClientExtendedQuerySync) (T, error)
	Describe func(msg *ClientExtendedQueryDescribe) (T, error)
	Close    func(msg *ClientExtendedQueryClose) (T, error)
	Flush    func(msg *ClientExtendedQueryFlush) (T, error)
}

// HandleDefault dispatches to the appropriate handler, or calls defaultHandler if the handler is nil.
func (h ClientExtendedQueryHandlers[T]) HandleDefault(msg ClientExtendedQuery, defaultHandler func(msg ClientExtendedQuery) (T, error)) (r T, err error) {
	switch msg := msg.(type) {
	case *ClientExtendedQueryParse:
		if h.Parse != nil {
			return h.Parse(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ClientExtendedQueryBind:
		if h.Bind != nil {
			return h.Bind(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ClientExtendedQueryExecute:
		if h.Execute != nil {
			return h.Execute(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ClientExtendedQuerySync:
		if h.Sync != nil {
			return h.Sync(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ClientExtendedQueryDescribe:
		if h.Describe != nil {
			return h.Describe(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ClientExtendedQueryClose:
		if h.Close != nil {
			return h.Close(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ClientExtendedQueryFlush:
		if h.Flush != nil {
			return h.Flush(msg)
		} else {
			return defaultHandler(msg)
		}
	}
	err = fmt.Errorf("unknown client extendedquery message: %T", msg)
	return
}

// Handle dispatches to the appropriate handler, or panics if the handler is nil.
func (h ClientExtendedQueryHandlers[T]) Handle(msg ClientExtendedQuery) (T, error) {
	return h.HandleDefault(msg, func(msg ClientExtendedQuery) (T, error) {
		panic(fmt.Sprintf("no handler defined for client extendedquery message: %T", msg))
	})
}
