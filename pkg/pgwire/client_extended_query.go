// Code generated by generate.go; DO NOT EDIT.

package pgwire

import (
	"github.com/jackc/pgx/v5/pgproto3"
)

// ClientExtendedQuery is implemented by all Client ExtendedQuery message wrapper types.
type ClientExtendedQuery interface {
	ExtendedQuery()
	PgwireMessage() pgproto3.Message
	Client() pgproto3.FrontendMessage
}

// Compile-time checks that all wrapper types implement the interface.
var (
	_ ClientExtendedQuery = ClientExtendedQueryParse{}
	_ ClientExtendedQuery = ClientExtendedQueryBind{}
	_ ClientExtendedQuery = ClientExtendedQueryExecute{}
	_ ClientExtendedQuery = ClientExtendedQuerySync{}
	_ ClientExtendedQuery = ClientExtendedQueryDescribe{}
	_ ClientExtendedQuery = ClientExtendedQueryClose{}
	_ ClientExtendedQuery = ClientExtendedQueryFlush{}
)

// Extended Query 1: parse text into a prepared statement.
type ClientExtendedQueryParse FromClient[*pgproto3.Parse]

func (ClientExtendedQueryParse) ExtendedQuery()                     {}
func (t ClientExtendedQueryParse) PgwireMessage() pgproto3.Message  { return t.T }
func (t ClientExtendedQueryParse) Client() pgproto3.FrontendMessage { return t.T }

// Extended Query 2: Bind parameters to a prepared statement.
type ClientExtendedQueryBind FromClient[*pgproto3.Bind]

func (ClientExtendedQueryBind) ExtendedQuery()                     {}
func (t ClientExtendedQueryBind) PgwireMessage() pgproto3.Message  { return t.T }
func (t ClientExtendedQueryBind) Client() pgproto3.FrontendMessage { return t.T }

// Extended Query 3: Execute a prepared statement, requesting N or all rows.
// May need to be called again if server replies PortalSuspended.
// Execute phase is always terminated by the appearance of exactly one of
// these messages:
// - PortalSuspended: execute ended before completion, call Execute again.
// - CommandComplete: success
// - ErrorResponse: failure
// - EmptyQueryResponse: the portal was created from an empty query string
type ClientExtendedQueryExecute FromClient[*pgproto3.Execute]

func (ClientExtendedQueryExecute) ExtendedQuery()                     {}
func (t ClientExtendedQueryExecute) PgwireMessage() pgproto3.Message  { return t.T }
func (t ClientExtendedQueryExecute) Client() pgproto3.FrontendMessage { return t.T }

// Extended Query 4: Command pipeline complete.
//
// Causes the backend to close the current transaction if it's not inside a
// BEGIN/COMMIT transaction block (“close” meaning to commit if no error, or
// roll back if error).
// then, a ReadyForQuery response is issued.
//
// The purpose of Sync is to provide a resynchronization point for error
// recovery. When an error is detected while processing any extended-query
// message, the backend issues ErrorResponse, then reads and discards
// messages until a Sync is reached, then issues ReadyForQuery and returns
// to normal message processing. (But note that no skipping occurs if an
// error is detected while processing Sync — this ensures that there is
// one and only one ReadyForQuery sent for each Sync.)
// In addition to these fundamental, required operations, there are several
// optional operations that can be used with extended-query protocol.
type ClientExtendedQuerySync FromClient[*pgproto3.Sync]

func (ClientExtendedQuerySync) ExtendedQuery()                     {}
func (t ClientExtendedQuerySync) PgwireMessage() pgproto3.Message  { return t.T }
func (t ClientExtendedQuerySync) Client() pgproto3.FrontendMessage { return t.T }

// Extended Query tool: Describe prepared statement or portal.
//
// The Describe message (portal variant) specifies the name of an existing
// portal (or an empty string for the unnamed portal). The response is a
// RowDescription message describing the rows that will be returned by
// executing the portal; or a NoData message if the portal does not
// contain a query that will return rows; or ErrorResponse if there is no
// such portal.
//
// The Describe message (statement variant) specifies the name of an
// existing prepared statement (or an empty string for the unnamed
// prepared statement). The response is a ParameterDescription message
// describing the parameters needed by the statement, followed by a
// RowDescription message describing the rows that will be returned when
// the statement is eventually executed (or a NoData message if the
// statement will not return rows). ErrorResponse is issued if there is no
// such prepared statement. Note that since Bind has not yet been issued,
// the formats to be used for returned columns are not yet known to the
// backend; the format code fields in the RowDescription message will be
// zeroes in this case.
type ClientExtendedQueryDescribe FromClient[*pgproto3.Describe]

func (ClientExtendedQueryDescribe) ExtendedQuery()                     {}
func (t ClientExtendedQueryDescribe) PgwireMessage() pgproto3.Message  { return t.T }
func (t ClientExtendedQueryDescribe) Client() pgproto3.FrontendMessage { return t.T }

// Close prepared statement/portal.
// Note that closing a prepared statement implicitly closes any open
// portals that were constructed from that statement.
type ClientExtendedQueryClose FromClient[*pgproto3.Close]

func (ClientExtendedQueryClose) ExtendedQuery()                     {}
func (t ClientExtendedQueryClose) PgwireMessage() pgproto3.Message  { return t.T }
func (t ClientExtendedQueryClose) Client() pgproto3.FrontendMessage { return t.T }

// The Flush message does not cause any specific output to be generated,
// but forces the backend to deliver any data pending in its output
// buffers. A Flush must be sent after any extended-query command except
// Sync, if the frontend wishes to examine the results of that command
// before issuing more commands. Without Flush, messages returned by the
// backend will be combined into the minimum possible number of packets to
// minimize network overhead.
type ClientExtendedQueryFlush FromClient[*pgproto3.Flush]

func (ClientExtendedQueryFlush) ExtendedQuery()                     {}
func (t ClientExtendedQueryFlush) PgwireMessage() pgproto3.Message  { return t.T }
func (t ClientExtendedQueryFlush) Client() pgproto3.FrontendMessage { return t.T }

// ToClientExtendedQuery converts a pgproto3.FrontendMessage to a ClientExtendedQuery if it matches one of the known types.
func ToClientExtendedQuery(msg pgproto3.FrontendMessage) (ClientExtendedQuery, bool) {
	switch m := msg.(type) {
	case *pgproto3.Parse:
		return ClientExtendedQueryParse{m}, true
	case *pgproto3.Bind:
		return ClientExtendedQueryBind{m}, true
	case *pgproto3.Execute:
		return ClientExtendedQueryExecute{m}, true
	case *pgproto3.Sync:
		return ClientExtendedQuerySync{m}, true
	case *pgproto3.Describe:
		return ClientExtendedQueryDescribe{m}, true
	case *pgproto3.Close:
		return ClientExtendedQueryClose{m}, true
	case *pgproto3.Flush:
		return ClientExtendedQueryFlush{m}, true
	}
	return nil, false
}
