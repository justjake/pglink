// Code generated by generate.go; DO NOT EDIT.

package pgwire

import (
	"fmt"

	"github.com/jackc/pgx/v5/pgproto3"
)

// ServerStartup is implemented by all Server Startup message wrapper types.
type ServerStartup interface {
	Startup()
	PgwireMessage() pgproto3.Message
	Server() pgproto3.BackendMessage
}

// Compile-time checks that all wrapper types implement the interface.
var (
	_ ServerStartup = (*ServerStartupAuthenticationCleartextPassword)(nil)
	_ ServerStartup = (*ServerStartupAuthenticationGSS)(nil)
	_ ServerStartup = (*ServerStartupAuthenticationGSSContinue)(nil)
	_ ServerStartup = (*ServerStartupAuthenticationMD5Password)(nil)
	_ ServerStartup = (*ServerStartupAuthenticationOk)(nil)
	_ ServerStartup = (*ServerStartupAuthenticationSASL)(nil)
	_ ServerStartup = (*ServerStartupAuthenticationSASLContinue)(nil)
	_ ServerStartup = (*ServerStartupAuthenticationSASLFinal)(nil)
	_ ServerStartup = (*ServerStartupBackendKeyData)(nil)
)

// ServerStartupAuthenticationCleartextPassword wraps *pgproto3.AuthenticationCleartextPassword from the server.
type ServerStartupAuthenticationCleartextPassword FromServer[*pgproto3.AuthenticationCleartextPassword]

func (*ServerStartupAuthenticationCleartextPassword) Startup() {}
func (t *ServerStartupAuthenticationCleartextPassword) PgwireMessage() pgproto3.Message {
	return t.Parse()
}
func (t *ServerStartupAuthenticationCleartextPassword) Server() pgproto3.BackendMessage {
	return t.Parse()
}
func (m *ServerStartupAuthenticationCleartextPassword) Parse() *pgproto3.AuthenticationCleartextPassword {
	return (*FromServer[*pgproto3.AuthenticationCleartextPassword])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerStartupAuthenticationCleartextPassword) Retain() ServerStartupAuthenticationCleartextPassword {
	src, parsed, isParsed := (*FromServer[*pgproto3.AuthenticationCleartextPassword])(&m).retainFields()
	return ServerStartupAuthenticationCleartextPassword{source: src, parsed: parsed, isParsed: isParsed}
}

// ServerStartupAuthenticationGSS wraps *pgproto3.AuthenticationGSS from the server.
type ServerStartupAuthenticationGSS FromServer[*pgproto3.AuthenticationGSS]

func (*ServerStartupAuthenticationGSS) Startup()                          {}
func (t *ServerStartupAuthenticationGSS) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t *ServerStartupAuthenticationGSS) Server() pgproto3.BackendMessage { return t.Parse() }
func (m *ServerStartupAuthenticationGSS) Parse() *pgproto3.AuthenticationGSS {
	return (*FromServer[*pgproto3.AuthenticationGSS])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerStartupAuthenticationGSS) Retain() ServerStartupAuthenticationGSS {
	src, parsed, isParsed := (*FromServer[*pgproto3.AuthenticationGSS])(&m).retainFields()
	return ServerStartupAuthenticationGSS{source: src, parsed: parsed, isParsed: isParsed}
}

// ServerStartupAuthenticationGSSContinue wraps *pgproto3.AuthenticationGSSContinue from the server.
type ServerStartupAuthenticationGSSContinue FromServer[*pgproto3.AuthenticationGSSContinue]

func (*ServerStartupAuthenticationGSSContinue) Startup()                          {}
func (t *ServerStartupAuthenticationGSSContinue) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t *ServerStartupAuthenticationGSSContinue) Server() pgproto3.BackendMessage { return t.Parse() }
func (m *ServerStartupAuthenticationGSSContinue) Parse() *pgproto3.AuthenticationGSSContinue {
	return (*FromServer[*pgproto3.AuthenticationGSSContinue])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerStartupAuthenticationGSSContinue) Retain() ServerStartupAuthenticationGSSContinue {
	src, parsed, isParsed := (*FromServer[*pgproto3.AuthenticationGSSContinue])(&m).retainFields()
	return ServerStartupAuthenticationGSSContinue{source: src, parsed: parsed, isParsed: isParsed}
}

// ServerStartupAuthenticationMD5Password wraps *pgproto3.AuthenticationMD5Password from the server.
type ServerStartupAuthenticationMD5Password FromServer[*pgproto3.AuthenticationMD5Password]

func (*ServerStartupAuthenticationMD5Password) Startup()                          {}
func (t *ServerStartupAuthenticationMD5Password) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t *ServerStartupAuthenticationMD5Password) Server() pgproto3.BackendMessage { return t.Parse() }
func (m *ServerStartupAuthenticationMD5Password) Parse() *pgproto3.AuthenticationMD5Password {
	return (*FromServer[*pgproto3.AuthenticationMD5Password])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerStartupAuthenticationMD5Password) Retain() ServerStartupAuthenticationMD5Password {
	src, parsed, isParsed := (*FromServer[*pgproto3.AuthenticationMD5Password])(&m).retainFields()
	return ServerStartupAuthenticationMD5Password{source: src, parsed: parsed, isParsed: isParsed}
}

// ServerStartupAuthenticationOk wraps *pgproto3.AuthenticationOk from the server.
type ServerStartupAuthenticationOk FromServer[*pgproto3.AuthenticationOk]

func (*ServerStartupAuthenticationOk) Startup()                          {}
func (t *ServerStartupAuthenticationOk) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t *ServerStartupAuthenticationOk) Server() pgproto3.BackendMessage { return t.Parse() }
func (m *ServerStartupAuthenticationOk) Parse() *pgproto3.AuthenticationOk {
	return (*FromServer[*pgproto3.AuthenticationOk])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerStartupAuthenticationOk) Retain() ServerStartupAuthenticationOk {
	src, parsed, isParsed := (*FromServer[*pgproto3.AuthenticationOk])(&m).retainFields()
	return ServerStartupAuthenticationOk{source: src, parsed: parsed, isParsed: isParsed}
}

// ServerStartupAuthenticationSASL wraps *pgproto3.AuthenticationSASL from the server.
type ServerStartupAuthenticationSASL FromServer[*pgproto3.AuthenticationSASL]

func (*ServerStartupAuthenticationSASL) Startup()                          {}
func (t *ServerStartupAuthenticationSASL) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t *ServerStartupAuthenticationSASL) Server() pgproto3.BackendMessage { return t.Parse() }
func (m *ServerStartupAuthenticationSASL) Parse() *pgproto3.AuthenticationSASL {
	return (*FromServer[*pgproto3.AuthenticationSASL])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerStartupAuthenticationSASL) Retain() ServerStartupAuthenticationSASL {
	src, parsed, isParsed := (*FromServer[*pgproto3.AuthenticationSASL])(&m).retainFields()
	return ServerStartupAuthenticationSASL{source: src, parsed: parsed, isParsed: isParsed}
}

// ServerStartupAuthenticationSASLContinue wraps *pgproto3.AuthenticationSASLContinue from the server.
type ServerStartupAuthenticationSASLContinue FromServer[*pgproto3.AuthenticationSASLContinue]

func (*ServerStartupAuthenticationSASLContinue) Startup()                          {}
func (t *ServerStartupAuthenticationSASLContinue) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t *ServerStartupAuthenticationSASLContinue) Server() pgproto3.BackendMessage { return t.Parse() }
func (m *ServerStartupAuthenticationSASLContinue) Parse() *pgproto3.AuthenticationSASLContinue {
	return (*FromServer[*pgproto3.AuthenticationSASLContinue])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerStartupAuthenticationSASLContinue) Retain() ServerStartupAuthenticationSASLContinue {
	src, parsed, isParsed := (*FromServer[*pgproto3.AuthenticationSASLContinue])(&m).retainFields()
	return ServerStartupAuthenticationSASLContinue{source: src, parsed: parsed, isParsed: isParsed}
}

// ServerStartupAuthenticationSASLFinal wraps *pgproto3.AuthenticationSASLFinal from the server.
type ServerStartupAuthenticationSASLFinal FromServer[*pgproto3.AuthenticationSASLFinal]

func (*ServerStartupAuthenticationSASLFinal) Startup()                          {}
func (t *ServerStartupAuthenticationSASLFinal) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t *ServerStartupAuthenticationSASLFinal) Server() pgproto3.BackendMessage { return t.Parse() }
func (m *ServerStartupAuthenticationSASLFinal) Parse() *pgproto3.AuthenticationSASLFinal {
	return (*FromServer[*pgproto3.AuthenticationSASLFinal])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerStartupAuthenticationSASLFinal) Retain() ServerStartupAuthenticationSASLFinal {
	src, parsed, isParsed := (*FromServer[*pgproto3.AuthenticationSASLFinal])(&m).retainFields()
	return ServerStartupAuthenticationSASLFinal{source: src, parsed: parsed, isParsed: isParsed}
}

// Secret key data for cancel requests.
// This should be already captured when we establish the connection.
type ServerStartupBackendKeyData FromServer[*pgproto3.BackendKeyData]

func (*ServerStartupBackendKeyData) Startup()                          {}
func (t *ServerStartupBackendKeyData) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t *ServerStartupBackendKeyData) Server() pgproto3.BackendMessage { return t.Parse() }
func (m *ServerStartupBackendKeyData) Parse() *pgproto3.BackendKeyData {
	return (*FromServer[*pgproto3.BackendKeyData])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerStartupBackendKeyData) Retain() ServerStartupBackendKeyData {
	src, parsed, isParsed := (*FromServer[*pgproto3.BackendKeyData])(&m).retainFields()
	return ServerStartupBackendKeyData{source: src, parsed: parsed, isParsed: isParsed}
}

// ToServerStartup converts a pgproto3.BackendMessage to a ServerStartup if it matches one of the known types.
// Note: This allocates. For zero-allocation iteration, use Cursor.AsServer().
func ToServerStartup(msg pgproto3.BackendMessage) (ServerStartup, bool) {
	switch m := msg.(type) {
	case *pgproto3.AuthenticationCleartextPassword:
		return (*ServerStartupAuthenticationCleartextPassword)(ServerParsed(m)), true
	case *pgproto3.AuthenticationGSS:
		return (*ServerStartupAuthenticationGSS)(ServerParsed(m)), true
	case *pgproto3.AuthenticationGSSContinue:
		return (*ServerStartupAuthenticationGSSContinue)(ServerParsed(m)), true
	case *pgproto3.AuthenticationMD5Password:
		return (*ServerStartupAuthenticationMD5Password)(ServerParsed(m)), true
	case *pgproto3.AuthenticationOk:
		return (*ServerStartupAuthenticationOk)(ServerParsed(m)), true
	case *pgproto3.AuthenticationSASL:
		return (*ServerStartupAuthenticationSASL)(ServerParsed(m)), true
	case *pgproto3.AuthenticationSASLContinue:
		return (*ServerStartupAuthenticationSASLContinue)(ServerParsed(m)), true
	case *pgproto3.AuthenticationSASLFinal:
		return (*ServerStartupAuthenticationSASLFinal)(ServerParsed(m)), true
	case *pgproto3.BackendKeyData:
		return (*ServerStartupBackendKeyData)(ServerParsed(m)), true
	}
	return nil, false
}

// ServerStartupHandlers provides type-safe handlers for each ServerStartup variant.
type ServerStartupHandlers[T any] struct {
	AuthenticationCleartextPassword func(msg *ServerStartupAuthenticationCleartextPassword) (T, error)
	AuthenticationGSS               func(msg *ServerStartupAuthenticationGSS) (T, error)
	AuthenticationGSSContinue       func(msg *ServerStartupAuthenticationGSSContinue) (T, error)
	AuthenticationMD5Password       func(msg *ServerStartupAuthenticationMD5Password) (T, error)
	AuthenticationOk                func(msg *ServerStartupAuthenticationOk) (T, error)
	AuthenticationSASL              func(msg *ServerStartupAuthenticationSASL) (T, error)
	AuthenticationSASLContinue      func(msg *ServerStartupAuthenticationSASLContinue) (T, error)
	AuthenticationSASLFinal         func(msg *ServerStartupAuthenticationSASLFinal) (T, error)
	BackendKeyData                  func(msg *ServerStartupBackendKeyData) (T, error)
}

// HandleDefault dispatches to the appropriate handler, or calls defaultHandler if the handler is nil.
func (h ServerStartupHandlers[T]) HandleDefault(msg ServerStartup, defaultHandler func(msg ServerStartup) (T, error)) (r T, err error) {
	switch msg := msg.(type) {
	case *ServerStartupAuthenticationCleartextPassword:
		if h.AuthenticationCleartextPassword != nil {
			return h.AuthenticationCleartextPassword(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ServerStartupAuthenticationGSS:
		if h.AuthenticationGSS != nil {
			return h.AuthenticationGSS(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ServerStartupAuthenticationGSSContinue:
		if h.AuthenticationGSSContinue != nil {
			return h.AuthenticationGSSContinue(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ServerStartupAuthenticationMD5Password:
		if h.AuthenticationMD5Password != nil {
			return h.AuthenticationMD5Password(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ServerStartupAuthenticationOk:
		if h.AuthenticationOk != nil {
			return h.AuthenticationOk(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ServerStartupAuthenticationSASL:
		if h.AuthenticationSASL != nil {
			return h.AuthenticationSASL(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ServerStartupAuthenticationSASLContinue:
		if h.AuthenticationSASLContinue != nil {
			return h.AuthenticationSASLContinue(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ServerStartupAuthenticationSASLFinal:
		if h.AuthenticationSASLFinal != nil {
			return h.AuthenticationSASLFinal(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ServerStartupBackendKeyData:
		if h.BackendKeyData != nil {
			return h.BackendKeyData(msg)
		} else {
			return defaultHandler(msg)
		}
	}
	err = fmt.Errorf("unknown server startup message: %T", msg)
	return
}

// Handle dispatches to the appropriate handler, or panics if the handler is nil.
func (h ServerStartupHandlers[T]) Handle(msg ServerStartup) (T, error) {
	return h.HandleDefault(msg, func(msg ServerStartup) (T, error) {
		panic(fmt.Sprintf("no handler defined for server startup message: %T", msg))
	})
}
