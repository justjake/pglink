// Code generated by generate.go; DO NOT EDIT.

package pgwire

import (
	"fmt"

	"github.com/jackc/pgx/v5/pgproto3"
)

// ServerStartup is implemented by all Server Startup message wrapper types.
type ServerStartup interface {
	Startup()
	PgwireMessage() pgproto3.Message
	Server() pgproto3.BackendMessage
	Raw() RawBody
}

// Compile-time checks that all wrapper types implement the interface.
var (
	_ ServerStartup = ServerStartupAuthenticationCleartextPassword{}
	_ ServerStartup = ServerStartupAuthenticationGSS{}
	_ ServerStartup = ServerStartupAuthenticationGSSContinue{}
	_ ServerStartup = ServerStartupAuthenticationMD5Password{}
	_ ServerStartup = ServerStartupAuthenticationOk{}
	_ ServerStartup = ServerStartupAuthenticationSASL{}
	_ ServerStartup = ServerStartupAuthenticationSASLContinue{}
	_ ServerStartup = ServerStartupAuthenticationSASLFinal{}
	_ ServerStartup = ServerStartupBackendKeyData{}
)

// ServerStartupAuthenticationCleartextPassword wraps *pgproto3.AuthenticationCleartextPassword from the server.
type ServerStartupAuthenticationCleartextPassword struct {
	LazyServer[*pgproto3.AuthenticationCleartextPassword]
}

func (ServerStartupAuthenticationCleartextPassword) Startup() {}
func (t ServerStartupAuthenticationCleartextPassword) PgwireMessage() pgproto3.Message {
	return t.Parse()
}
func (t ServerStartupAuthenticationCleartextPassword) Server() pgproto3.BackendMessage {
	return t.Parse()
}

// ServerStartupAuthenticationGSS wraps *pgproto3.AuthenticationGSS from the server.
type ServerStartupAuthenticationGSS struct {
	LazyServer[*pgproto3.AuthenticationGSS]
}

func (ServerStartupAuthenticationGSS) Startup()                          {}
func (t ServerStartupAuthenticationGSS) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t ServerStartupAuthenticationGSS) Server() pgproto3.BackendMessage { return t.Parse() }

// ServerStartupAuthenticationGSSContinue wraps *pgproto3.AuthenticationGSSContinue from the server.
type ServerStartupAuthenticationGSSContinue struct {
	LazyServer[*pgproto3.AuthenticationGSSContinue]
}

func (ServerStartupAuthenticationGSSContinue) Startup()                          {}
func (t ServerStartupAuthenticationGSSContinue) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t ServerStartupAuthenticationGSSContinue) Server() pgproto3.BackendMessage { return t.Parse() }

// ServerStartupAuthenticationMD5Password wraps *pgproto3.AuthenticationMD5Password from the server.
type ServerStartupAuthenticationMD5Password struct {
	LazyServer[*pgproto3.AuthenticationMD5Password]
}

func (ServerStartupAuthenticationMD5Password) Startup()                          {}
func (t ServerStartupAuthenticationMD5Password) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t ServerStartupAuthenticationMD5Password) Server() pgproto3.BackendMessage { return t.Parse() }

// ServerStartupAuthenticationOk wraps *pgproto3.AuthenticationOk from the server.
type ServerStartupAuthenticationOk struct {
	LazyServer[*pgproto3.AuthenticationOk]
}

func (ServerStartupAuthenticationOk) Startup()                          {}
func (t ServerStartupAuthenticationOk) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t ServerStartupAuthenticationOk) Server() pgproto3.BackendMessage { return t.Parse() }

// ServerStartupAuthenticationSASL wraps *pgproto3.AuthenticationSASL from the server.
type ServerStartupAuthenticationSASL struct {
	LazyServer[*pgproto3.AuthenticationSASL]
}

func (ServerStartupAuthenticationSASL) Startup()                          {}
func (t ServerStartupAuthenticationSASL) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t ServerStartupAuthenticationSASL) Server() pgproto3.BackendMessage { return t.Parse() }

// ServerStartupAuthenticationSASLContinue wraps *pgproto3.AuthenticationSASLContinue from the server.
type ServerStartupAuthenticationSASLContinue struct {
	LazyServer[*pgproto3.AuthenticationSASLContinue]
}

func (ServerStartupAuthenticationSASLContinue) Startup()                          {}
func (t ServerStartupAuthenticationSASLContinue) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t ServerStartupAuthenticationSASLContinue) Server() pgproto3.BackendMessage { return t.Parse() }

// ServerStartupAuthenticationSASLFinal wraps *pgproto3.AuthenticationSASLFinal from the server.
type ServerStartupAuthenticationSASLFinal struct {
	LazyServer[*pgproto3.AuthenticationSASLFinal]
}

func (ServerStartupAuthenticationSASLFinal) Startup()                          {}
func (t ServerStartupAuthenticationSASLFinal) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t ServerStartupAuthenticationSASLFinal) Server() pgproto3.BackendMessage { return t.Parse() }

// Secret key data for cancel requests.
// This should be already captured when we establish the connection.
type ServerStartupBackendKeyData struct {
	LazyServer[*pgproto3.BackendKeyData]
}

func (ServerStartupBackendKeyData) Startup()                          {}
func (t ServerStartupBackendKeyData) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t ServerStartupBackendKeyData) Server() pgproto3.BackendMessage { return t.Parse() }

// ToServerStartup converts a pgproto3.BackendMessage to a ServerStartup if it matches one of the known types.
func ToServerStartup(msg pgproto3.BackendMessage) (ServerStartup, bool) {
	switch m := msg.(type) {
	case *pgproto3.AuthenticationCleartextPassword:
		return ServerStartupAuthenticationCleartextPassword{NewLazyServerFromParsed(m)}, true
	case *pgproto3.AuthenticationGSS:
		return ServerStartupAuthenticationGSS{NewLazyServerFromParsed(m)}, true
	case *pgproto3.AuthenticationGSSContinue:
		return ServerStartupAuthenticationGSSContinue{NewLazyServerFromParsed(m)}, true
	case *pgproto3.AuthenticationMD5Password:
		return ServerStartupAuthenticationMD5Password{NewLazyServerFromParsed(m)}, true
	case *pgproto3.AuthenticationOk:
		return ServerStartupAuthenticationOk{NewLazyServerFromParsed(m)}, true
	case *pgproto3.AuthenticationSASL:
		return ServerStartupAuthenticationSASL{NewLazyServerFromParsed(m)}, true
	case *pgproto3.AuthenticationSASLContinue:
		return ServerStartupAuthenticationSASLContinue{NewLazyServerFromParsed(m)}, true
	case *pgproto3.AuthenticationSASLFinal:
		return ServerStartupAuthenticationSASLFinal{NewLazyServerFromParsed(m)}, true
	case *pgproto3.BackendKeyData:
		return ServerStartupBackendKeyData{NewLazyServerFromParsed(m)}, true
	}
	return nil, false
}

// ServerStartupHandlers provides type-safe handlers for each ServerStartup variant.
type ServerStartupHandlers[T any] struct {
	AuthenticationCleartextPassword func(msg ServerStartupAuthenticationCleartextPassword) (T, error)
	AuthenticationGSS               func(msg ServerStartupAuthenticationGSS) (T, error)
	AuthenticationGSSContinue       func(msg ServerStartupAuthenticationGSSContinue) (T, error)
	AuthenticationMD5Password       func(msg ServerStartupAuthenticationMD5Password) (T, error)
	AuthenticationOk                func(msg ServerStartupAuthenticationOk) (T, error)
	AuthenticationSASL              func(msg ServerStartupAuthenticationSASL) (T, error)
	AuthenticationSASLContinue      func(msg ServerStartupAuthenticationSASLContinue) (T, error)
	AuthenticationSASLFinal         func(msg ServerStartupAuthenticationSASLFinal) (T, error)
	BackendKeyData                  func(msg ServerStartupBackendKeyData) (T, error)
}

// HandleDefault dispatches to the appropriate handler, or calls defaultHandler if the handler is nil.
func (h ServerStartupHandlers[T]) HandleDefault(msg ServerStartup, defaultHandler func(msg ServerStartup) (T, error)) (r T, err error) {
	switch msg := msg.(type) {
	case ServerStartupAuthenticationCleartextPassword:
		if h.AuthenticationCleartextPassword != nil {
			return h.AuthenticationCleartextPassword(msg)
		} else {
			return defaultHandler(msg)
		}
	case ServerStartupAuthenticationGSS:
		if h.AuthenticationGSS != nil {
			return h.AuthenticationGSS(msg)
		} else {
			return defaultHandler(msg)
		}
	case ServerStartupAuthenticationGSSContinue:
		if h.AuthenticationGSSContinue != nil {
			return h.AuthenticationGSSContinue(msg)
		} else {
			return defaultHandler(msg)
		}
	case ServerStartupAuthenticationMD5Password:
		if h.AuthenticationMD5Password != nil {
			return h.AuthenticationMD5Password(msg)
		} else {
			return defaultHandler(msg)
		}
	case ServerStartupAuthenticationOk:
		if h.AuthenticationOk != nil {
			return h.AuthenticationOk(msg)
		} else {
			return defaultHandler(msg)
		}
	case ServerStartupAuthenticationSASL:
		if h.AuthenticationSASL != nil {
			return h.AuthenticationSASL(msg)
		} else {
			return defaultHandler(msg)
		}
	case ServerStartupAuthenticationSASLContinue:
		if h.AuthenticationSASLContinue != nil {
			return h.AuthenticationSASLContinue(msg)
		} else {
			return defaultHandler(msg)
		}
	case ServerStartupAuthenticationSASLFinal:
		if h.AuthenticationSASLFinal != nil {
			return h.AuthenticationSASLFinal(msg)
		} else {
			return defaultHandler(msg)
		}
	case ServerStartupBackendKeyData:
		if h.BackendKeyData != nil {
			return h.BackendKeyData(msg)
		} else {
			return defaultHandler(msg)
		}
	}
	err = fmt.Errorf("unknown server startup message: %T", msg)
	return
}

// Handle dispatches to the appropriate handler, or panics if the handler is nil.
func (h ServerStartupHandlers[T]) Handle(msg ServerStartup) (T, error) {
	return h.HandleDefault(msg, func(msg ServerStartup) (T, error) {
		panic(fmt.Sprintf("no handler defined for server startup message: %T", msg))
	})
}
