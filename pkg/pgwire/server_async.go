// Code generated by generate.go; DO NOT EDIT.

package pgwire

import (
	"fmt"

	"github.com/jackc/pgx/v5/pgproto3"
)

// ServerAsync is implemented by all Server Async message wrapper types.
type ServerAsync interface {
	Async()
	PgwireMessage() pgproto3.Message
	Server() pgproto3.BackendMessage
}

// Compile-time checks that all wrapper types implement the interface.
var (
	_ ServerAsync = ServerAsyncNoticeResponse{}
	_ ServerAsync = ServerAsyncNotificationResponse{}
	_ ServerAsync = ServerAsyncParameterStatus{}
)

// Warning message.
type ServerAsyncNoticeResponse FromServer[*pgproto3.NoticeResponse]

func (ServerAsyncNoticeResponse) Async() {}
func (t ServerAsyncNoticeResponse) PgwireMessage() pgproto3.Message {
	return (*FromServer[*pgproto3.NoticeResponse])(&t).Parse()
}
func (t ServerAsyncNoticeResponse) Server() pgproto3.BackendMessage {
	return (*FromServer[*pgproto3.NoticeResponse])(&t).Parse()
}
func (m *ServerAsyncNoticeResponse) Parse() *pgproto3.NoticeResponse {
	return (*FromServer[*pgproto3.NoticeResponse])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerAsyncNoticeResponse) Retain() ServerAsyncNoticeResponse {
	src, parsed, isParsed := (*FromServer[*pgproto3.NoticeResponse])(&m).retainFields()
	return ServerAsyncNoticeResponse{source: src, parsed: parsed, isParsed: isParsed}
}

// LISTEN/NOTIFY notification.
type ServerAsyncNotificationResponse FromServer[*pgproto3.NotificationResponse]

func (ServerAsyncNotificationResponse) Async() {}
func (t ServerAsyncNotificationResponse) PgwireMessage() pgproto3.Message {
	return (*FromServer[*pgproto3.NotificationResponse])(&t).Parse()
}
func (t ServerAsyncNotificationResponse) Server() pgproto3.BackendMessage {
	return (*FromServer[*pgproto3.NotificationResponse])(&t).Parse()
}
func (m *ServerAsyncNotificationResponse) Parse() *pgproto3.NotificationResponse {
	return (*FromServer[*pgproto3.NotificationResponse])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerAsyncNotificationResponse) Retain() ServerAsyncNotificationResponse {
	src, parsed, isParsed := (*FromServer[*pgproto3.NotificationResponse])(&m).retainFields()
	return ServerAsyncNotificationResponse{source: src, parsed: parsed, isParsed: isParsed}
}

// Informs client that runtime parameter value changed.
type ServerAsyncParameterStatus FromServer[*pgproto3.ParameterStatus]

func (ServerAsyncParameterStatus) Async() {}
func (t ServerAsyncParameterStatus) PgwireMessage() pgproto3.Message {
	return (*FromServer[*pgproto3.ParameterStatus])(&t).Parse()
}
func (t ServerAsyncParameterStatus) Server() pgproto3.BackendMessage {
	return (*FromServer[*pgproto3.ParameterStatus])(&t).Parse()
}
func (m *ServerAsyncParameterStatus) Parse() *pgproto3.ParameterStatus {
	return (*FromServer[*pgproto3.ParameterStatus])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerAsyncParameterStatus) Retain() ServerAsyncParameterStatus {
	src, parsed, isParsed := (*FromServer[*pgproto3.ParameterStatus])(&m).retainFields()
	return ServerAsyncParameterStatus{source: src, parsed: parsed, isParsed: isParsed}
}

// ToServerAsync converts a pgproto3.BackendMessage to a ServerAsync if it matches one of the known types.
func ToServerAsync(msg pgproto3.BackendMessage) (ServerAsync, bool) {
	switch m := msg.(type) {
	case *pgproto3.NoticeResponse:
		return ServerAsyncNoticeResponse(ServerParsed(m)), true
	case *pgproto3.NotificationResponse:
		return ServerAsyncNotificationResponse(ServerParsed(m)), true
	case *pgproto3.ParameterStatus:
		return ServerAsyncParameterStatus(ServerParsed(m)), true
	}
	return nil, false
}

// ServerAsyncHandlers provides type-safe handlers for each ServerAsync variant.
type ServerAsyncHandlers[T any] struct {
	NoticeResponse       func(msg ServerAsyncNoticeResponse) (T, error)
	NotificationResponse func(msg ServerAsyncNotificationResponse) (T, error)
	ParameterStatus      func(msg ServerAsyncParameterStatus) (T, error)
}

// HandleDefault dispatches to the appropriate handler, or calls defaultHandler if the handler is nil.
func (h ServerAsyncHandlers[T]) HandleDefault(msg ServerAsync, defaultHandler func(msg ServerAsync) (T, error)) (r T, err error) {
	switch msg := msg.(type) {
	case ServerAsyncNoticeResponse:
		if h.NoticeResponse != nil {
			return h.NoticeResponse(msg)
		} else {
			return defaultHandler(msg)
		}
	case ServerAsyncNotificationResponse:
		if h.NotificationResponse != nil {
			return h.NotificationResponse(msg)
		} else {
			return defaultHandler(msg)
		}
	case ServerAsyncParameterStatus:
		if h.ParameterStatus != nil {
			return h.ParameterStatus(msg)
		} else {
			return defaultHandler(msg)
		}
	}
	err = fmt.Errorf("unknown server async message: %T", msg)
	return
}

// Handle dispatches to the appropriate handler, or panics if the handler is nil.
func (h ServerAsyncHandlers[T]) Handle(msg ServerAsync) (T, error) {
	return h.HandleDefault(msg, func(msg ServerAsync) (T, error) {
		panic(fmt.Sprintf("no handler defined for server async message: %T", msg))
	})
}
