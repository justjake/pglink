// Code generated by generate.go; DO NOT EDIT.

package pgwire

import (
	"fmt"

	"github.com/jackc/pgx/v5/pgproto3"
)

// ClientCancel is implemented by all Client Cancel message wrapper types.
type ClientCancel interface {
	Cancel()
	PgwireMessage() pgproto3.Message
	Client() pgproto3.FrontendMessage
}

// Compile-time checks that all wrapper types implement the interface.
var (
	_ ClientCancel = (*ClientCancelCancelRequest)(nil)
)

// ClientCancelCancelRequest wraps *pgproto3.CancelRequest from the client.
type ClientCancelCancelRequest FromClient[*pgproto3.CancelRequest]

func (*ClientCancelCancelRequest) Cancel()                            {}
func (t *ClientCancelCancelRequest) PgwireMessage() pgproto3.Message  { return t.Parse() }
func (t *ClientCancelCancelRequest) Client() pgproto3.FrontendMessage { return t.Parse() }
func (m *ClientCancelCancelRequest) Parse() *pgproto3.CancelRequest {
	return (*FromClient[*pgproto3.CancelRequest])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ClientCancelCancelRequest) Retain() ClientCancelCancelRequest {
	src, parsed, isParsed := (*FromClient[*pgproto3.CancelRequest])(&m).retainFields()
	return ClientCancelCancelRequest{source: src, parsed: parsed, isParsed: isParsed}
}

// ToClientCancel converts a pgproto3.FrontendMessage to a ClientCancel if it matches one of the known types.
// Note: This allocates. For zero-allocation iteration, use Cursor.AsClient().
func ToClientCancel(msg pgproto3.FrontendMessage) (ClientCancel, bool) {
	switch m := msg.(type) {
	case *pgproto3.CancelRequest:
		return (*ClientCancelCancelRequest)(ClientParsed(m)), true
	}
	return nil, false
}

// ClientCancelHandlers provides type-safe handlers for each ClientCancel variant.
type ClientCancelHandlers[T any] struct {
	CancelRequest func(msg *ClientCancelCancelRequest) (T, error)
}

// HandleDefault dispatches to the appropriate handler, or calls defaultHandler if the handler is nil.
func (h ClientCancelHandlers[T]) HandleDefault(msg ClientCancel, defaultHandler func(msg ClientCancel) (T, error)) (r T, err error) {
	switch msg := msg.(type) {
	case *ClientCancelCancelRequest:
		if h.CancelRequest != nil {
			return h.CancelRequest(msg)
		} else {
			return defaultHandler(msg)
		}
	}
	err = fmt.Errorf("unknown client cancel message: %T", msg)
	return
}

// Handle dispatches to the appropriate handler, or panics if the handler is nil.
func (h ClientCancelHandlers[T]) Handle(msg ClientCancel) (T, error) {
	return h.HandleDefault(msg, func(msg ClientCancel) (T, error) {
		panic(fmt.Sprintf("no handler defined for client cancel message: %T", msg))
	})
}
