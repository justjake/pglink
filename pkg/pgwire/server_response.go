// Code generated by generate.go; DO NOT EDIT.

package pgwire

import (
	"fmt"

	"github.com/jackc/pgx/v5/pgproto3"
)

// ServerResponse is implemented by all Server Response message wrapper types.
type ServerResponse interface {
	Response()
	PgwireMessage() pgproto3.Message
	Server() pgproto3.BackendMessage
	Raw() RawBody
}

// Compile-time checks that all wrapper types implement the interface.
var (
	_ ServerResponse = ServerResponseReadyForQuery{}
	_ ServerResponse = ServerResponseCommandComplete{}
	_ ServerResponse = ServerResponseDataRow{}
	_ ServerResponse = ServerResponseEmptyQueryResponse{}
	_ ServerResponse = ServerResponseErrorResponse{}
	_ ServerResponse = ServerResponseFunctionCallResponse{}
)

// Start-up completed.
// Simple Query mode: ready for next query.
// Extended Query mode: response to Sync; backend no longer ignoring messages, ready for next command.
type ServerResponseReadyForQuery struct {
	LazyServer[*pgproto3.ReadyForQuery]
}

func (ServerResponseReadyForQuery) Response()                         {}
func (t ServerResponseReadyForQuery) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t ServerResponseReadyForQuery) Server() pgproto3.BackendMessage { return t.Parse() }

// SQL command completed normally.
type ServerResponseCommandComplete struct {
	LazyServer[*pgproto3.CommandComplete]
}

func (ServerResponseCommandComplete) Response()                         {}
func (t ServerResponseCommandComplete) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t ServerResponseCommandComplete) Server() pgproto3.BackendMessage { return t.Parse() }

// Query results (both query modes)
type ServerResponseDataRow struct{ LazyServer[*pgproto3.DataRow] }

func (ServerResponseDataRow) Response()                         {}
func (t ServerResponseDataRow) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t ServerResponseDataRow) Server() pgproto3.BackendMessage { return t.Parse() }

// Response to empty query.
type ServerResponseEmptyQueryResponse struct {
	LazyServer[*pgproto3.EmptyQueryResponse]
}

func (ServerResponseEmptyQueryResponse) Response()                         {}
func (t ServerResponseEmptyQueryResponse) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t ServerResponseEmptyQueryResponse) Server() pgproto3.BackendMessage { return t.Parse() }

// Error response.
type ServerResponseErrorResponse struct {
	LazyServer[*pgproto3.ErrorResponse]
}

func (ServerResponseErrorResponse) Response()                         {}
func (t ServerResponseErrorResponse) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t ServerResponseErrorResponse) Server() pgproto3.BackendMessage { return t.Parse() }

// Response to function call.
type ServerResponseFunctionCallResponse struct {
	LazyServer[*pgproto3.FunctionCallResponse]
}

func (ServerResponseFunctionCallResponse) Response()                         {}
func (t ServerResponseFunctionCallResponse) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t ServerResponseFunctionCallResponse) Server() pgproto3.BackendMessage { return t.Parse() }

// ToServerResponse converts a pgproto3.BackendMessage to a ServerResponse if it matches one of the known types.
func ToServerResponse(msg pgproto3.BackendMessage) (ServerResponse, bool) {
	switch m := msg.(type) {
	case *pgproto3.ReadyForQuery:
		return ServerResponseReadyForQuery{NewLazyServerFromParsed(m)}, true
	case *pgproto3.CommandComplete:
		return ServerResponseCommandComplete{NewLazyServerFromParsed(m)}, true
	case *pgproto3.DataRow:
		return ServerResponseDataRow{NewLazyServerFromParsed(m)}, true
	case *pgproto3.EmptyQueryResponse:
		return ServerResponseEmptyQueryResponse{NewLazyServerFromParsed(m)}, true
	case *pgproto3.ErrorResponse:
		return ServerResponseErrorResponse{NewLazyServerFromParsed(m)}, true
	case *pgproto3.FunctionCallResponse:
		return ServerResponseFunctionCallResponse{NewLazyServerFromParsed(m)}, true
	}
	return nil, false
}

// ServerResponseHandlers provides type-safe handlers for each ServerResponse variant.
type ServerResponseHandlers[T any] struct {
	ReadyForQuery        func(msg ServerResponseReadyForQuery) (T, error)
	CommandComplete      func(msg ServerResponseCommandComplete) (T, error)
	DataRow              func(msg ServerResponseDataRow) (T, error)
	EmptyQueryResponse   func(msg ServerResponseEmptyQueryResponse) (T, error)
	ErrorResponse        func(msg ServerResponseErrorResponse) (T, error)
	FunctionCallResponse func(msg ServerResponseFunctionCallResponse) (T, error)
}

// HandleDefault dispatches to the appropriate handler, or calls defaultHandler if the handler is nil.
func (h ServerResponseHandlers[T]) HandleDefault(msg ServerResponse, defaultHandler func(msg ServerResponse) (T, error)) (r T, err error) {
	switch msg := msg.(type) {
	case ServerResponseReadyForQuery:
		if h.ReadyForQuery != nil {
			return h.ReadyForQuery(msg)
		} else {
			return defaultHandler(msg)
		}
	case ServerResponseCommandComplete:
		if h.CommandComplete != nil {
			return h.CommandComplete(msg)
		} else {
			return defaultHandler(msg)
		}
	case ServerResponseDataRow:
		if h.DataRow != nil {
			return h.DataRow(msg)
		} else {
			return defaultHandler(msg)
		}
	case ServerResponseEmptyQueryResponse:
		if h.EmptyQueryResponse != nil {
			return h.EmptyQueryResponse(msg)
		} else {
			return defaultHandler(msg)
		}
	case ServerResponseErrorResponse:
		if h.ErrorResponse != nil {
			return h.ErrorResponse(msg)
		} else {
			return defaultHandler(msg)
		}
	case ServerResponseFunctionCallResponse:
		if h.FunctionCallResponse != nil {
			return h.FunctionCallResponse(msg)
		} else {
			return defaultHandler(msg)
		}
	}
	err = fmt.Errorf("unknown server response message: %T", msg)
	return
}

// Handle dispatches to the appropriate handler, or panics if the handler is nil.
func (h ServerResponseHandlers[T]) Handle(msg ServerResponse) (T, error) {
	return h.HandleDefault(msg, func(msg ServerResponse) (T, error) {
		panic(fmt.Sprintf("no handler defined for server response message: %T", msg))
	})
}
