// Code generated by generate.go; DO NOT EDIT.

package pgwire

import (
	"fmt"

	"github.com/jackc/pgx/v5/pgproto3"
)

// ServerResponse is implemented by all Server Response message wrapper types.
type ServerResponse interface {
	Response()
	PgwireMessage() pgproto3.Message
	Server() pgproto3.BackendMessage
}

// Compile-time checks that all wrapper types implement the interface.
var (
	_ ServerResponse = (*ServerResponseReadyForQuery)(nil)
	_ ServerResponse = (*ServerResponseCommandComplete)(nil)
	_ ServerResponse = (*ServerResponseDataRow)(nil)
	_ ServerResponse = (*ServerResponseEmptyQueryResponse)(nil)
	_ ServerResponse = (*ServerResponseErrorResponse)(nil)
	_ ServerResponse = (*ServerResponseFunctionCallResponse)(nil)
)

// Start-up completed.
// Simple Query mode: ready for next query.
// Extended Query mode: response to Sync; backend no longer ignoring messages, ready for next command.
type ServerResponseReadyForQuery FromServer[*pgproto3.ReadyForQuery]

func (*ServerResponseReadyForQuery) Response() {}
func (t *ServerResponseReadyForQuery) PgwireMessage() pgproto3.Message {
	return (*FromServer[*pgproto3.ReadyForQuery])(t).Parse()
}
func (t *ServerResponseReadyForQuery) Server() pgproto3.BackendMessage {
	return (*FromServer[*pgproto3.ReadyForQuery])(t).Parse()
}
func (m *ServerResponseReadyForQuery) Parse() *pgproto3.ReadyForQuery {
	return (*FromServer[*pgproto3.ReadyForQuery])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerResponseReadyForQuery) Retain() ServerResponseReadyForQuery {
	src, parsed, isParsed := (*FromServer[*pgproto3.ReadyForQuery])(&m).retainFields()
	return ServerResponseReadyForQuery{source: src, parsed: parsed, isParsed: isParsed}
}

// SQL command completed normally.
type ServerResponseCommandComplete FromServer[*pgproto3.CommandComplete]

func (*ServerResponseCommandComplete) Response() {}
func (t *ServerResponseCommandComplete) PgwireMessage() pgproto3.Message {
	return (*FromServer[*pgproto3.CommandComplete])(t).Parse()
}
func (t *ServerResponseCommandComplete) Server() pgproto3.BackendMessage {
	return (*FromServer[*pgproto3.CommandComplete])(t).Parse()
}
func (m *ServerResponseCommandComplete) Parse() *pgproto3.CommandComplete {
	return (*FromServer[*pgproto3.CommandComplete])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerResponseCommandComplete) Retain() ServerResponseCommandComplete {
	src, parsed, isParsed := (*FromServer[*pgproto3.CommandComplete])(&m).retainFields()
	return ServerResponseCommandComplete{source: src, parsed: parsed, isParsed: isParsed}
}

// Query results (both query modes)
type ServerResponseDataRow FromServer[*pgproto3.DataRow]

func (*ServerResponseDataRow) Response() {}
func (t *ServerResponseDataRow) PgwireMessage() pgproto3.Message {
	return (*FromServer[*pgproto3.DataRow])(t).Parse()
}
func (t *ServerResponseDataRow) Server() pgproto3.BackendMessage {
	return (*FromServer[*pgproto3.DataRow])(t).Parse()
}
func (m *ServerResponseDataRow) Parse() *pgproto3.DataRow {
	return (*FromServer[*pgproto3.DataRow])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerResponseDataRow) Retain() ServerResponseDataRow {
	src, parsed, isParsed := (*FromServer[*pgproto3.DataRow])(&m).retainFields()
	return ServerResponseDataRow{source: src, parsed: parsed, isParsed: isParsed}
}

// Response to empty query.
type ServerResponseEmptyQueryResponse FromServer[*pgproto3.EmptyQueryResponse]

func (*ServerResponseEmptyQueryResponse) Response() {}
func (t *ServerResponseEmptyQueryResponse) PgwireMessage() pgproto3.Message {
	return (*FromServer[*pgproto3.EmptyQueryResponse])(t).Parse()
}
func (t *ServerResponseEmptyQueryResponse) Server() pgproto3.BackendMessage {
	return (*FromServer[*pgproto3.EmptyQueryResponse])(t).Parse()
}
func (m *ServerResponseEmptyQueryResponse) Parse() *pgproto3.EmptyQueryResponse {
	return (*FromServer[*pgproto3.EmptyQueryResponse])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerResponseEmptyQueryResponse) Retain() ServerResponseEmptyQueryResponse {
	src, parsed, isParsed := (*FromServer[*pgproto3.EmptyQueryResponse])(&m).retainFields()
	return ServerResponseEmptyQueryResponse{source: src, parsed: parsed, isParsed: isParsed}
}

// Error response.
type ServerResponseErrorResponse FromServer[*pgproto3.ErrorResponse]

func (*ServerResponseErrorResponse) Response() {}
func (t *ServerResponseErrorResponse) PgwireMessage() pgproto3.Message {
	return (*FromServer[*pgproto3.ErrorResponse])(t).Parse()
}
func (t *ServerResponseErrorResponse) Server() pgproto3.BackendMessage {
	return (*FromServer[*pgproto3.ErrorResponse])(t).Parse()
}
func (m *ServerResponseErrorResponse) Parse() *pgproto3.ErrorResponse {
	return (*FromServer[*pgproto3.ErrorResponse])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerResponseErrorResponse) Retain() ServerResponseErrorResponse {
	src, parsed, isParsed := (*FromServer[*pgproto3.ErrorResponse])(&m).retainFields()
	return ServerResponseErrorResponse{source: src, parsed: parsed, isParsed: isParsed}
}

// Response to function call.
type ServerResponseFunctionCallResponse FromServer[*pgproto3.FunctionCallResponse]

func (*ServerResponseFunctionCallResponse) Response() {}
func (t *ServerResponseFunctionCallResponse) PgwireMessage() pgproto3.Message {
	return (*FromServer[*pgproto3.FunctionCallResponse])(t).Parse()
}
func (t *ServerResponseFunctionCallResponse) Server() pgproto3.BackendMessage {
	return (*FromServer[*pgproto3.FunctionCallResponse])(t).Parse()
}
func (m *ServerResponseFunctionCallResponse) Parse() *pgproto3.FunctionCallResponse {
	return (*FromServer[*pgproto3.FunctionCallResponse])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerResponseFunctionCallResponse) Retain() ServerResponseFunctionCallResponse {
	src, parsed, isParsed := (*FromServer[*pgproto3.FunctionCallResponse])(&m).retainFields()
	return ServerResponseFunctionCallResponse{source: src, parsed: parsed, isParsed: isParsed}
}

// ToServerResponse converts a pgproto3.BackendMessage to a ServerResponse if it matches one of the known types.
// Note: This allocates. For zero-allocation iteration, use Cursor.AsServer().
func ToServerResponse(msg pgproto3.BackendMessage) (ServerResponse, bool) {
	switch m := msg.(type) {
	case *pgproto3.ReadyForQuery:
		return (*ServerResponseReadyForQuery)(ServerParsed(m)), true
	case *pgproto3.CommandComplete:
		return (*ServerResponseCommandComplete)(ServerParsed(m)), true
	case *pgproto3.DataRow:
		return (*ServerResponseDataRow)(ServerParsed(m)), true
	case *pgproto3.EmptyQueryResponse:
		return (*ServerResponseEmptyQueryResponse)(ServerParsed(m)), true
	case *pgproto3.ErrorResponse:
		return (*ServerResponseErrorResponse)(ServerParsed(m)), true
	case *pgproto3.FunctionCallResponse:
		return (*ServerResponseFunctionCallResponse)(ServerParsed(m)), true
	}
	return nil, false
}

// ServerResponseHandlers provides type-safe handlers for each ServerResponse variant.
type ServerResponseHandlers[T any] struct {
	ReadyForQuery        func(msg *ServerResponseReadyForQuery) (T, error)
	CommandComplete      func(msg *ServerResponseCommandComplete) (T, error)
	DataRow              func(msg *ServerResponseDataRow) (T, error)
	EmptyQueryResponse   func(msg *ServerResponseEmptyQueryResponse) (T, error)
	ErrorResponse        func(msg *ServerResponseErrorResponse) (T, error)
	FunctionCallResponse func(msg *ServerResponseFunctionCallResponse) (T, error)
}

// HandleDefault dispatches to the appropriate handler, or calls defaultHandler if the handler is nil.
func (h ServerResponseHandlers[T]) HandleDefault(msg ServerResponse, defaultHandler func(msg ServerResponse) (T, error)) (r T, err error) {
	switch msg := msg.(type) {
	case *ServerResponseReadyForQuery:
		if h.ReadyForQuery != nil {
			return h.ReadyForQuery(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ServerResponseCommandComplete:
		if h.CommandComplete != nil {
			return h.CommandComplete(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ServerResponseDataRow:
		if h.DataRow != nil {
			return h.DataRow(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ServerResponseEmptyQueryResponse:
		if h.EmptyQueryResponse != nil {
			return h.EmptyQueryResponse(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ServerResponseErrorResponse:
		if h.ErrorResponse != nil {
			return h.ErrorResponse(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ServerResponseFunctionCallResponse:
		if h.FunctionCallResponse != nil {
			return h.FunctionCallResponse(msg)
		} else {
			return defaultHandler(msg)
		}
	}
	err = fmt.Errorf("unknown server response message: %T", msg)
	return
}

// Handle dispatches to the appropriate handler, or panics if the handler is nil.
func (h ServerResponseHandlers[T]) Handle(msg ServerResponse) (T, error) {
	return h.HandleDefault(msg, func(msg ServerResponse) (T, error) {
		panic(fmt.Sprintf("no handler defined for server response message: %T", msg))
	})
}
