// Code generated by generate.go; DO NOT EDIT.

package pgwire

import (
	"fmt"

	"github.com/jackc/pgx/v5/pgproto3"
)

// ClientCopy is implemented by all Client Copy message wrapper types.
type ClientCopy interface {
	Copy()
	PgwireMessage() pgproto3.Message
	Client() pgproto3.FrontendMessage
}

// Compile-time checks that all wrapper types implement the interface.
var (
	_ ClientCopy = (*ClientCopyCopyData)(nil)
	_ ClientCopy = (*ClientCopyCopyDone)(nil)
	_ ClientCopy = (*ClientCopyCopyFail)(nil)
)

// ClientCopyCopyData wraps *pgproto3.CopyData from the client.
type ClientCopyCopyData FromClient[*pgproto3.CopyData]

func (*ClientCopyCopyData) Copy() {}
func (t *ClientCopyCopyData) PgwireMessage() pgproto3.Message {
	return (*FromClient[*pgproto3.CopyData])(t).Parse()
}
func (t *ClientCopyCopyData) Client() pgproto3.FrontendMessage {
	return (*FromClient[*pgproto3.CopyData])(t).Parse()
}
func (m *ClientCopyCopyData) Parse() *pgproto3.CopyData {
	return (*FromClient[*pgproto3.CopyData])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ClientCopyCopyData) Retain() ClientCopyCopyData {
	src, parsed, isParsed := (*FromClient[*pgproto3.CopyData])(&m).retainFields()
	return ClientCopyCopyData{source: src, parsed: parsed, isParsed: isParsed}
}

// ClientCopyCopyDone wraps *pgproto3.CopyDone from the client.
type ClientCopyCopyDone FromClient[*pgproto3.CopyDone]

func (*ClientCopyCopyDone) Copy() {}
func (t *ClientCopyCopyDone) PgwireMessage() pgproto3.Message {
	return (*FromClient[*pgproto3.CopyDone])(t).Parse()
}
func (t *ClientCopyCopyDone) Client() pgproto3.FrontendMessage {
	return (*FromClient[*pgproto3.CopyDone])(t).Parse()
}
func (m *ClientCopyCopyDone) Parse() *pgproto3.CopyDone {
	return (*FromClient[*pgproto3.CopyDone])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ClientCopyCopyDone) Retain() ClientCopyCopyDone {
	src, parsed, isParsed := (*FromClient[*pgproto3.CopyDone])(&m).retainFields()
	return ClientCopyCopyDone{source: src, parsed: parsed, isParsed: isParsed}
}

// ClientCopyCopyFail wraps *pgproto3.CopyFail from the client.
type ClientCopyCopyFail FromClient[*pgproto3.CopyFail]

func (*ClientCopyCopyFail) Copy() {}
func (t *ClientCopyCopyFail) PgwireMessage() pgproto3.Message {
	return (*FromClient[*pgproto3.CopyFail])(t).Parse()
}
func (t *ClientCopyCopyFail) Client() pgproto3.FrontendMessage {
	return (*FromClient[*pgproto3.CopyFail])(t).Parse()
}
func (m *ClientCopyCopyFail) Parse() *pgproto3.CopyFail {
	return (*FromClient[*pgproto3.CopyFail])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ClientCopyCopyFail) Retain() ClientCopyCopyFail {
	src, parsed, isParsed := (*FromClient[*pgproto3.CopyFail])(&m).retainFields()
	return ClientCopyCopyFail{source: src, parsed: parsed, isParsed: isParsed}
}

// ToClientCopy converts a pgproto3.FrontendMessage to a ClientCopy if it matches one of the known types.
// Note: This allocates. For zero-allocation iteration, use Cursor.AsClient().
func ToClientCopy(msg pgproto3.FrontendMessage) (ClientCopy, bool) {
	switch m := msg.(type) {
	case *pgproto3.CopyData:
		return (*ClientCopyCopyData)(ClientParsed(m)), true
	case *pgproto3.CopyDone:
		return (*ClientCopyCopyDone)(ClientParsed(m)), true
	case *pgproto3.CopyFail:
		return (*ClientCopyCopyFail)(ClientParsed(m)), true
	}
	return nil, false
}

// ClientCopyHandlers provides type-safe handlers for each ClientCopy variant.
type ClientCopyHandlers[T any] struct {
	CopyData func(msg *ClientCopyCopyData) (T, error)
	CopyDone func(msg *ClientCopyCopyDone) (T, error)
	CopyFail func(msg *ClientCopyCopyFail) (T, error)
}

// HandleDefault dispatches to the appropriate handler, or calls defaultHandler if the handler is nil.
func (h ClientCopyHandlers[T]) HandleDefault(msg ClientCopy, defaultHandler func(msg ClientCopy) (T, error)) (r T, err error) {
	switch msg := msg.(type) {
	case *ClientCopyCopyData:
		if h.CopyData != nil {
			return h.CopyData(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ClientCopyCopyDone:
		if h.CopyDone != nil {
			return h.CopyDone(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ClientCopyCopyFail:
		if h.CopyFail != nil {
			return h.CopyFail(msg)
		} else {
			return defaultHandler(msg)
		}
	}
	err = fmt.Errorf("unknown client copy message: %T", msg)
	return
}

// Handle dispatches to the appropriate handler, or panics if the handler is nil.
func (h ClientCopyHandlers[T]) Handle(msg ClientCopy) (T, error) {
	return h.HandleDefault(msg, func(msg ClientCopy) (T, error) {
		panic(fmt.Sprintf("no handler defined for client copy message: %T", msg))
	})
}
