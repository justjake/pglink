// Code generated by generate.go; DO NOT EDIT.

package pgwire

import (
	"fmt"

	"github.com/jackc/pgx/v5/pgproto3"
)

// ClientCopy is implemented by all Client Copy message wrapper types.
type ClientCopy interface {
	Copy()
	PgwireMessage() pgproto3.Message
	Client() pgproto3.FrontendMessage
}

// Compile-time checks that all wrapper types implement the interface.
var (
	_ ClientCopy = ClientCopyCopyData{}
	_ ClientCopy = ClientCopyCopyDone{}
	_ ClientCopy = ClientCopyCopyFail{}
)

// ClientCopyCopyData wraps *pgproto3.CopyData from the client.
type ClientCopyCopyData FromClient[*pgproto3.CopyData]

func (ClientCopyCopyData) Copy()                              {}
func (t ClientCopyCopyData) PgwireMessage() pgproto3.Message  { return t.T }
func (t ClientCopyCopyData) Client() pgproto3.FrontendMessage { return t.T }

// ClientCopyCopyDone wraps *pgproto3.CopyDone from the client.
type ClientCopyCopyDone FromClient[*pgproto3.CopyDone]

func (ClientCopyCopyDone) Copy()                              {}
func (t ClientCopyCopyDone) PgwireMessage() pgproto3.Message  { return t.T }
func (t ClientCopyCopyDone) Client() pgproto3.FrontendMessage { return t.T }

// ClientCopyCopyFail wraps *pgproto3.CopyFail from the client.
type ClientCopyCopyFail FromClient[*pgproto3.CopyFail]

func (ClientCopyCopyFail) Copy()                              {}
func (t ClientCopyCopyFail) PgwireMessage() pgproto3.Message  { return t.T }
func (t ClientCopyCopyFail) Client() pgproto3.FrontendMessage { return t.T }

// ToClientCopy converts a pgproto3.FrontendMessage to a ClientCopy if it matches one of the known types.
func ToClientCopy(msg pgproto3.FrontendMessage) (ClientCopy, bool) {
	switch m := msg.(type) {
	case *pgproto3.CopyData:
		return ClientCopyCopyData{m}, true
	case *pgproto3.CopyDone:
		return ClientCopyCopyDone{m}, true
	case *pgproto3.CopyFail:
		return ClientCopyCopyFail{m}, true
	}
	return nil, false
}

// ClientCopyHandlers provides type-safe handlers for each ClientCopy variant.
type ClientCopyHandlers[T any] struct {
	CopyData func(msg ClientCopyCopyData) (T, error)
	CopyDone func(msg ClientCopyCopyDone) (T, error)
	CopyFail func(msg ClientCopyCopyFail) (T, error)
}

// HandleDefault dispatches to the appropriate handler, or calls defaultHandler if the handler is nil.
func (h ClientCopyHandlers[T]) HandleDefault(msg ClientCopy, defaultHandler func(msg ClientCopy) (T, error)) (r T, err error) {
	switch msg := msg.(type) {
	case ClientCopyCopyData:
		if h.CopyData != nil {
			return h.CopyData(msg)
		} else {
			return defaultHandler(msg)
		}
	case ClientCopyCopyDone:
		if h.CopyDone != nil {
			return h.CopyDone(msg)
		} else {
			return defaultHandler(msg)
		}
	case ClientCopyCopyFail:
		if h.CopyFail != nil {
			return h.CopyFail(msg)
		} else {
			return defaultHandler(msg)
		}
	}
	err = fmt.Errorf("unknown client copy message: %T", msg)
	return
}

// Handle dispatches to the appropriate handler, or panics if the handler is nil.
func (h ClientCopyHandlers[T]) Handle(msg ClientCopy) (T, error) {
	return h.HandleDefault(msg, func(msg ClientCopy) (T, error) {
		panic(fmt.Sprintf("no handler defined for client copy message: %T", msg))
	})
}
