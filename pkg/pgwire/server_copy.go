// Code generated by generate.go; DO NOT EDIT.

package pgwire

import (
	"fmt"

	"github.com/jackc/pgx/v5/pgproto3"
)

// ServerCopy is implemented by all Server Copy message wrapper types.
type ServerCopy interface {
	Copy()
	PgwireMessage() pgproto3.Message
	Server() pgproto3.BackendMessage
}

// Compile-time checks that all wrapper types implement the interface.
var (
	_ ServerCopy = (*ServerCopyCopyInResponse)(nil)
	_ ServerCopy = (*ServerCopyCopyOutResponse)(nil)
	_ ServerCopy = (*ServerCopyCopyBothResponse)(nil)
	_ ServerCopy = (*ServerCopyCopyData)(nil)
	_ ServerCopy = (*ServerCopyCopyDone)(nil)
)

// Response to COPY FROM STDIN.
// Backend ready to copy data from client to server.
// Starts CopyIn mode.
type ServerCopyCopyInResponse FromServer[*pgproto3.CopyInResponse]

func (*ServerCopyCopyInResponse) Copy()                             {}
func (t *ServerCopyCopyInResponse) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t *ServerCopyCopyInResponse) Server() pgproto3.BackendMessage { return t.Parse() }
func (m *ServerCopyCopyInResponse) Parse() *pgproto3.CopyInResponse {
	return (*FromServer[*pgproto3.CopyInResponse])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerCopyCopyInResponse) Retain() ServerCopyCopyInResponse {
	src, parsed, isParsed := (*FromServer[*pgproto3.CopyInResponse])(&m).retainFields()
	return ServerCopyCopyInResponse{source: src, parsed: parsed, isParsed: isParsed}
}

// Response to COPY TO STDOUT.
// Backend ready to copy data from server to client.
// Starts CopyOut mode.
type ServerCopyCopyOutResponse FromServer[*pgproto3.CopyOutResponse]

func (*ServerCopyCopyOutResponse) Copy()                             {}
func (t *ServerCopyCopyOutResponse) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t *ServerCopyCopyOutResponse) Server() pgproto3.BackendMessage { return t.Parse() }
func (m *ServerCopyCopyOutResponse) Parse() *pgproto3.CopyOutResponse {
	return (*FromServer[*pgproto3.CopyOutResponse])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerCopyCopyOutResponse) Retain() ServerCopyCopyOutResponse {
	src, parsed, isParsed := (*FromServer[*pgproto3.CopyOutResponse])(&m).retainFields()
	return ServerCopyCopyOutResponse{source: src, parsed: parsed, isParsed: isParsed}
}

// Response to Replication.
type ServerCopyCopyBothResponse FromServer[*pgproto3.CopyBothResponse]

func (*ServerCopyCopyBothResponse) Copy()                             {}
func (t *ServerCopyCopyBothResponse) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t *ServerCopyCopyBothResponse) Server() pgproto3.BackendMessage { return t.Parse() }
func (m *ServerCopyCopyBothResponse) Parse() *pgproto3.CopyBothResponse {
	return (*FromServer[*pgproto3.CopyBothResponse])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerCopyCopyBothResponse) Retain() ServerCopyCopyBothResponse {
	src, parsed, isParsed := (*FromServer[*pgproto3.CopyBothResponse])(&m).retainFields()
	return ServerCopyCopyBothResponse{source: src, parsed: parsed, isParsed: isParsed}
}

// Copy Mode: data row.
type ServerCopyCopyData FromServer[*pgproto3.CopyData]

func (*ServerCopyCopyData) Copy()                             {}
func (t *ServerCopyCopyData) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t *ServerCopyCopyData) Server() pgproto3.BackendMessage { return t.Parse() }
func (m *ServerCopyCopyData) Parse() *pgproto3.CopyData {
	return (*FromServer[*pgproto3.CopyData])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerCopyCopyData) Retain() ServerCopyCopyData {
	src, parsed, isParsed := (*FromServer[*pgproto3.CopyData])(&m).retainFields()
	return ServerCopyCopyData{source: src, parsed: parsed, isParsed: isParsed}
}

// Copy Mode: copy completed.
type ServerCopyCopyDone FromServer[*pgproto3.CopyDone]

func (*ServerCopyCopyDone) Copy()                             {}
func (t *ServerCopyCopyDone) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t *ServerCopyCopyDone) Server() pgproto3.BackendMessage { return t.Parse() }
func (m *ServerCopyCopyDone) Parse() *pgproto3.CopyDone {
	return (*FromServer[*pgproto3.CopyDone])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerCopyCopyDone) Retain() ServerCopyCopyDone {
	src, parsed, isParsed := (*FromServer[*pgproto3.CopyDone])(&m).retainFields()
	return ServerCopyCopyDone{source: src, parsed: parsed, isParsed: isParsed}
}

// ToServerCopy converts a pgproto3.BackendMessage to a ServerCopy if it matches one of the known types.
// Note: This allocates. For zero-allocation iteration, use Cursor.AsServer().
func ToServerCopy(msg pgproto3.BackendMessage) (ServerCopy, bool) {
	switch m := msg.(type) {
	case *pgproto3.CopyInResponse:
		return (*ServerCopyCopyInResponse)(ServerParsed(m)), true
	case *pgproto3.CopyOutResponse:
		return (*ServerCopyCopyOutResponse)(ServerParsed(m)), true
	case *pgproto3.CopyBothResponse:
		return (*ServerCopyCopyBothResponse)(ServerParsed(m)), true
	case *pgproto3.CopyData:
		return (*ServerCopyCopyData)(ServerParsed(m)), true
	case *pgproto3.CopyDone:
		return (*ServerCopyCopyDone)(ServerParsed(m)), true
	}
	return nil, false
}

// ServerCopyHandlers provides type-safe handlers for each ServerCopy variant.
type ServerCopyHandlers[T any] struct {
	CopyInResponse   func(msg *ServerCopyCopyInResponse) (T, error)
	CopyOutResponse  func(msg *ServerCopyCopyOutResponse) (T, error)
	CopyBothResponse func(msg *ServerCopyCopyBothResponse) (T, error)
	CopyData         func(msg *ServerCopyCopyData) (T, error)
	CopyDone         func(msg *ServerCopyCopyDone) (T, error)
}

// HandleDefault dispatches to the appropriate handler, or calls defaultHandler if the handler is nil.
func (h ServerCopyHandlers[T]) HandleDefault(msg ServerCopy, defaultHandler func(msg ServerCopy) (T, error)) (r T, err error) {
	switch msg := msg.(type) {
	case *ServerCopyCopyInResponse:
		if h.CopyInResponse != nil {
			return h.CopyInResponse(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ServerCopyCopyOutResponse:
		if h.CopyOutResponse != nil {
			return h.CopyOutResponse(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ServerCopyCopyBothResponse:
		if h.CopyBothResponse != nil {
			return h.CopyBothResponse(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ServerCopyCopyData:
		if h.CopyData != nil {
			return h.CopyData(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ServerCopyCopyDone:
		if h.CopyDone != nil {
			return h.CopyDone(msg)
		} else {
			return defaultHandler(msg)
		}
	}
	err = fmt.Errorf("unknown server copy message: %T", msg)
	return
}

// Handle dispatches to the appropriate handler, or panics if the handler is nil.
func (h ServerCopyHandlers[T]) Handle(msg ServerCopy) (T, error) {
	return h.HandleDefault(msg, func(msg ServerCopy) (T, error) {
		panic(fmt.Sprintf("no handler defined for server copy message: %T", msg))
	})
}
