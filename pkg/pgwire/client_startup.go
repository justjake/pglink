// Code generated by generate.go; DO NOT EDIT.

package pgwire

import (
	"fmt"

	"github.com/jackc/pgx/v5/pgproto3"
)

// ClientStartup is implemented by all Client Startup message wrapper types.
type ClientStartup interface {
	Startup()
	PgwireMessage() pgproto3.Message
	Client() pgproto3.FrontendMessage
	Raw() RawBody
}

// Compile-time checks that all wrapper types implement the interface.
var (
	_ ClientStartup = ClientStartupGSSEncRequest{}
	_ ClientStartup = ClientStartupGSSResponse{}
	_ ClientStartup = ClientStartupPasswordMessage{}
	_ ClientStartup = ClientStartupSASLInitialResponse{}
	_ ClientStartup = ClientStartupSASLResponse{}
	_ ClientStartup = ClientStartupSSLRequest{}
	_ ClientStartup = ClientStartupStartupMessage{}
)

// ClientStartupGSSEncRequest wraps *pgproto3.GSSEncRequest from the client.
type ClientStartupGSSEncRequest struct {
	LazyClient[*pgproto3.GSSEncRequest]
}

func (ClientStartupGSSEncRequest) Startup()                           {}
func (t ClientStartupGSSEncRequest) PgwireMessage() pgproto3.Message  { return t.Parse() }
func (t ClientStartupGSSEncRequest) Client() pgproto3.FrontendMessage { return t.Parse() }

// ClientStartupGSSResponse wraps *pgproto3.GSSResponse from the client.
type ClientStartupGSSResponse struct {
	LazyClient[*pgproto3.GSSResponse]
}

func (ClientStartupGSSResponse) Startup()                           {}
func (t ClientStartupGSSResponse) PgwireMessage() pgproto3.Message  { return t.Parse() }
func (t ClientStartupGSSResponse) Client() pgproto3.FrontendMessage { return t.Parse() }

// ClientStartupPasswordMessage wraps *pgproto3.PasswordMessage from the client.
type ClientStartupPasswordMessage struct {
	LazyClient[*pgproto3.PasswordMessage]
}

func (ClientStartupPasswordMessage) Startup()                           {}
func (t ClientStartupPasswordMessage) PgwireMessage() pgproto3.Message  { return t.Parse() }
func (t ClientStartupPasswordMessage) Client() pgproto3.FrontendMessage { return t.Parse() }

// ClientStartupSASLInitialResponse wraps *pgproto3.SASLInitialResponse from the client.
type ClientStartupSASLInitialResponse struct {
	LazyClient[*pgproto3.SASLInitialResponse]
}

func (ClientStartupSASLInitialResponse) Startup()                           {}
func (t ClientStartupSASLInitialResponse) PgwireMessage() pgproto3.Message  { return t.Parse() }
func (t ClientStartupSASLInitialResponse) Client() pgproto3.FrontendMessage { return t.Parse() }

// ClientStartupSASLResponse wraps *pgproto3.SASLResponse from the client.
type ClientStartupSASLResponse struct {
	LazyClient[*pgproto3.SASLResponse]
}

func (ClientStartupSASLResponse) Startup()                           {}
func (t ClientStartupSASLResponse) PgwireMessage() pgproto3.Message  { return t.Parse() }
func (t ClientStartupSASLResponse) Client() pgproto3.FrontendMessage { return t.Parse() }

// ClientStartupSSLRequest wraps *pgproto3.SSLRequest from the client.
type ClientStartupSSLRequest struct {
	LazyClient[*pgproto3.SSLRequest]
}

func (ClientStartupSSLRequest) Startup()                           {}
func (t ClientStartupSSLRequest) PgwireMessage() pgproto3.Message  { return t.Parse() }
func (t ClientStartupSSLRequest) Client() pgproto3.FrontendMessage { return t.Parse() }

// ClientStartupStartupMessage wraps *pgproto3.StartupMessage from the client.
type ClientStartupStartupMessage struct {
	LazyClient[*pgproto3.StartupMessage]
}

func (ClientStartupStartupMessage) Startup()                           {}
func (t ClientStartupStartupMessage) PgwireMessage() pgproto3.Message  { return t.Parse() }
func (t ClientStartupStartupMessage) Client() pgproto3.FrontendMessage { return t.Parse() }

// ToClientStartup converts a pgproto3.FrontendMessage to a ClientStartup if it matches one of the known types.
func ToClientStartup(msg pgproto3.FrontendMessage) (ClientStartup, bool) {
	switch m := msg.(type) {
	case *pgproto3.GSSEncRequest:
		return ClientStartupGSSEncRequest{NewLazyClientFromParsed(m)}, true
	case *pgproto3.GSSResponse:
		return ClientStartupGSSResponse{NewLazyClientFromParsed(m)}, true
	case *pgproto3.PasswordMessage:
		return ClientStartupPasswordMessage{NewLazyClientFromParsed(m)}, true
	case *pgproto3.SASLInitialResponse:
		return ClientStartupSASLInitialResponse{NewLazyClientFromParsed(m)}, true
	case *pgproto3.SASLResponse:
		return ClientStartupSASLResponse{NewLazyClientFromParsed(m)}, true
	case *pgproto3.SSLRequest:
		return ClientStartupSSLRequest{NewLazyClientFromParsed(m)}, true
	case *pgproto3.StartupMessage:
		return ClientStartupStartupMessage{NewLazyClientFromParsed(m)}, true
	}
	return nil, false
}

// ClientStartupHandlers provides type-safe handlers for each ClientStartup variant.
type ClientStartupHandlers[T any] struct {
	GSSEncRequest       func(msg ClientStartupGSSEncRequest) (T, error)
	GSSResponse         func(msg ClientStartupGSSResponse) (T, error)
	PasswordMessage     func(msg ClientStartupPasswordMessage) (T, error)
	SASLInitialResponse func(msg ClientStartupSASLInitialResponse) (T, error)
	SASLResponse        func(msg ClientStartupSASLResponse) (T, error)
	SSLRequest          func(msg ClientStartupSSLRequest) (T, error)
	StartupMessage      func(msg ClientStartupStartupMessage) (T, error)
}

// HandleDefault dispatches to the appropriate handler, or calls defaultHandler if the handler is nil.
func (h ClientStartupHandlers[T]) HandleDefault(msg ClientStartup, defaultHandler func(msg ClientStartup) (T, error)) (r T, err error) {
	switch msg := msg.(type) {
	case ClientStartupGSSEncRequest:
		if h.GSSEncRequest != nil {
			return h.GSSEncRequest(msg)
		} else {
			return defaultHandler(msg)
		}
	case ClientStartupGSSResponse:
		if h.GSSResponse != nil {
			return h.GSSResponse(msg)
		} else {
			return defaultHandler(msg)
		}
	case ClientStartupPasswordMessage:
		if h.PasswordMessage != nil {
			return h.PasswordMessage(msg)
		} else {
			return defaultHandler(msg)
		}
	case ClientStartupSASLInitialResponse:
		if h.SASLInitialResponse != nil {
			return h.SASLInitialResponse(msg)
		} else {
			return defaultHandler(msg)
		}
	case ClientStartupSASLResponse:
		if h.SASLResponse != nil {
			return h.SASLResponse(msg)
		} else {
			return defaultHandler(msg)
		}
	case ClientStartupSSLRequest:
		if h.SSLRequest != nil {
			return h.SSLRequest(msg)
		} else {
			return defaultHandler(msg)
		}
	case ClientStartupStartupMessage:
		if h.StartupMessage != nil {
			return h.StartupMessage(msg)
		} else {
			return defaultHandler(msg)
		}
	}
	err = fmt.Errorf("unknown client startup message: %T", msg)
	return
}

// Handle dispatches to the appropriate handler, or panics if the handler is nil.
func (h ClientStartupHandlers[T]) Handle(msg ClientStartup) (T, error) {
	return h.HandleDefault(msg, func(msg ClientStartup) (T, error) {
		panic(fmt.Sprintf("no handler defined for client startup message: %T", msg))
	})
}
