// Code generated by generate.go; DO NOT EDIT.

package pgwire

import (
	"fmt"
	"io"

	"github.com/jackc/pgx/v5/pgproto3"
)

// ClientTerminateConn is implemented by all Client TerminateConn message wrapper types.
type ClientTerminateConn interface {
	TerminateConn()
	PgwireMessage() pgproto3.Message
	Client() pgproto3.FrontendMessage
	Raw() RawBody
}

// Compile-time checks that all wrapper types implement the interface.
var (
	_ ClientTerminateConn = ClientTerminateConnTerminate{}
)

// ClientTerminateConnTerminate wraps *pgproto3.Terminate from the client.
type ClientTerminateConnTerminate LazyClient[*pgproto3.Terminate]

func (ClientTerminateConnTerminate) TerminateConn() {}
func (t ClientTerminateConnTerminate) PgwireMessage() pgproto3.Message {
	return (*LazyClient[*pgproto3.Terminate])(&t).Parse()
}
func (t ClientTerminateConnTerminate) Client() pgproto3.FrontendMessage {
	return (*LazyClient[*pgproto3.Terminate])(&t).Parse()
}
func (m ClientTerminateConnTerminate) Raw() RawBody { return LazyClient[*pgproto3.Terminate](m).Raw() }
func (m *ClientTerminateConnTerminate) Parse() *pgproto3.Terminate {
	return (*LazyClient[*pgproto3.Terminate])(m).Parse()
}
func (m ClientTerminateConnTerminate) IsParsed() bool {
	return LazyClient[*pgproto3.Terminate](m).IsParsed()
}
func (m ClientTerminateConnTerminate) Body() []byte { return LazyClient[*pgproto3.Terminate](m).Body() }
func (m *ClientTerminateConnTerminate) WriteTo(w io.Writer) (int64, error) {
	return (*LazyClient[*pgproto3.Terminate])(m).WriteTo(w)
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ClientTerminateConnTerminate) Retain() ClientTerminateConnTerminate {
	src, parsed, isParsed := (*LazyClient[*pgproto3.Terminate])(&m).retainFields()
	return ClientTerminateConnTerminate{source: src, parsed: parsed, isParsed: isParsed}
}

// ToClientTerminateConn converts a pgproto3.FrontendMessage to a ClientTerminateConn if it matches one of the known types.
func ToClientTerminateConn(msg pgproto3.FrontendMessage) (ClientTerminateConn, bool) {
	switch m := msg.(type) {
	case *pgproto3.Terminate:
		return ClientTerminateConnTerminate(ClientParsed(m)), true
	}
	return nil, false
}

// ClientTerminateConnHandlers provides type-safe handlers for each ClientTerminateConn variant.
type ClientTerminateConnHandlers[T any] struct {
	Terminate func(msg ClientTerminateConnTerminate) (T, error)
}

// HandleDefault dispatches to the appropriate handler, or calls defaultHandler if the handler is nil.
func (h ClientTerminateConnHandlers[T]) HandleDefault(msg ClientTerminateConn, defaultHandler func(msg ClientTerminateConn) (T, error)) (r T, err error) {
	switch msg := msg.(type) {
	case ClientTerminateConnTerminate:
		if h.Terminate != nil {
			return h.Terminate(msg)
		} else {
			return defaultHandler(msg)
		}
	}
	err = fmt.Errorf("unknown client terminateconn message: %T", msg)
	return
}

// Handle dispatches to the appropriate handler, or panics if the handler is nil.
func (h ClientTerminateConnHandlers[T]) Handle(msg ClientTerminateConn) (T, error) {
	return h.HandleDefault(msg, func(msg ClientTerminateConn) (T, error) {
		panic(fmt.Sprintf("no handler defined for client terminateconn message: %T", msg))
	})
}
