// Code generated by generate.go; DO NOT EDIT.

package pgwire

import (
	"fmt"

	"github.com/jackc/pgx/v5/pgproto3"
)

// ServerExtendedQuery is implemented by all Server ExtendedQuery message wrapper types.
type ServerExtendedQuery interface {
	ExtendedQuery()
	PgwireMessage() pgproto3.Message
	Server() pgproto3.BackendMessage
}

// Compile-time checks that all wrapper types implement the interface.
var (
	_ ServerExtendedQuery = (*ServerExtendedQueryParseComplete)(nil)
	_ ServerExtendedQuery = (*ServerExtendedQueryBindComplete)(nil)
	_ ServerExtendedQuery = (*ServerExtendedQueryParameterDescription)(nil)
	_ ServerExtendedQuery = (*ServerExtendedQueryRowDescription)(nil)
	_ ServerExtendedQuery = (*ServerExtendedQueryNoData)(nil)
	_ ServerExtendedQuery = (*ServerExtendedQueryPortalSuspended)(nil)
	_ ServerExtendedQuery = (*ServerExtendedQueryCloseComplete)(nil)
)

// Response to Parse.
type ServerExtendedQueryParseComplete FromServer[*pgproto3.ParseComplete]

func (*ServerExtendedQueryParseComplete) ExtendedQuery()                    {}
func (t *ServerExtendedQueryParseComplete) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t *ServerExtendedQueryParseComplete) Server() pgproto3.BackendMessage { return t.Parse() }
func (m *ServerExtendedQueryParseComplete) Parse() *pgproto3.ParseComplete {
	return (*FromServer[*pgproto3.ParseComplete])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerExtendedQueryParseComplete) Retain() ServerExtendedQueryParseComplete {
	src, parsed, isParsed := (*FromServer[*pgproto3.ParseComplete])(&m).retainFields()
	return ServerExtendedQueryParseComplete{source: src, parsed: parsed, isParsed: isParsed}
}

// Response to Bind.
type ServerExtendedQueryBindComplete FromServer[*pgproto3.BindComplete]

func (*ServerExtendedQueryBindComplete) ExtendedQuery()                    {}
func (t *ServerExtendedQueryBindComplete) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t *ServerExtendedQueryBindComplete) Server() pgproto3.BackendMessage { return t.Parse() }
func (m *ServerExtendedQueryBindComplete) Parse() *pgproto3.BindComplete {
	return (*FromServer[*pgproto3.BindComplete])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerExtendedQueryBindComplete) Retain() ServerExtendedQueryBindComplete {
	src, parsed, isParsed := (*FromServer[*pgproto3.BindComplete])(&m).retainFields()
	return ServerExtendedQueryBindComplete{source: src, parsed: parsed, isParsed: isParsed}
}

// Response to Describe of prepared statement.
type ServerExtendedQueryParameterDescription FromServer[*pgproto3.ParameterDescription]

func (*ServerExtendedQueryParameterDescription) ExtendedQuery()                    {}
func (t *ServerExtendedQueryParameterDescription) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t *ServerExtendedQueryParameterDescription) Server() pgproto3.BackendMessage { return t.Parse() }
func (m *ServerExtendedQueryParameterDescription) Parse() *pgproto3.ParameterDescription {
	return (*FromServer[*pgproto3.ParameterDescription])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerExtendedQueryParameterDescription) Retain() ServerExtendedQueryParameterDescription {
	src, parsed, isParsed := (*FromServer[*pgproto3.ParameterDescription])(&m).retainFields()
	return ServerExtendedQueryParameterDescription{source: src, parsed: parsed, isParsed: isParsed}
}

// Response to Describe of portal or statement that returns data.
type ServerExtendedQueryRowDescription FromServer[*pgproto3.RowDescription]

func (*ServerExtendedQueryRowDescription) ExtendedQuery()                    {}
func (t *ServerExtendedQueryRowDescription) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t *ServerExtendedQueryRowDescription) Server() pgproto3.BackendMessage { return t.Parse() }
func (m *ServerExtendedQueryRowDescription) Parse() *pgproto3.RowDescription {
	return (*FromServer[*pgproto3.RowDescription])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerExtendedQueryRowDescription) Retain() ServerExtendedQueryRowDescription {
	src, parsed, isParsed := (*FromServer[*pgproto3.RowDescription])(&m).retainFields()
	return ServerExtendedQueryRowDescription{source: src, parsed: parsed, isParsed: isParsed}
}

// Response to Describe of portal or statement that doesn't return data.
type ServerExtendedQueryNoData FromServer[*pgproto3.NoData]

func (*ServerExtendedQueryNoData) ExtendedQuery()                    {}
func (t *ServerExtendedQueryNoData) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t *ServerExtendedQueryNoData) Server() pgproto3.BackendMessage { return t.Parse() }
func (m *ServerExtendedQueryNoData) Parse() *pgproto3.NoData {
	return (*FromServer[*pgproto3.NoData])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerExtendedQueryNoData) Retain() ServerExtendedQueryNoData {
	src, parsed, isParsed := (*FromServer[*pgproto3.NoData])(&m).retainFields()
	return ServerExtendedQueryNoData{source: src, parsed: parsed, isParsed: isParsed}
}

// Response to Execute if there are additional rows / the execute did not
// complete during the Execute call, the client should call Execute again.
type ServerExtendedQueryPortalSuspended FromServer[*pgproto3.PortalSuspended]

func (*ServerExtendedQueryPortalSuspended) ExtendedQuery()                    {}
func (t *ServerExtendedQueryPortalSuspended) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t *ServerExtendedQueryPortalSuspended) Server() pgproto3.BackendMessage { return t.Parse() }
func (m *ServerExtendedQueryPortalSuspended) Parse() *pgproto3.PortalSuspended {
	return (*FromServer[*pgproto3.PortalSuspended])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerExtendedQueryPortalSuspended) Retain() ServerExtendedQueryPortalSuspended {
	src, parsed, isParsed := (*FromServer[*pgproto3.PortalSuspended])(&m).retainFields()
	return ServerExtendedQueryPortalSuspended{source: src, parsed: parsed, isParsed: isParsed}
}

// Response to Close of prepared statement or portal.
type ServerExtendedQueryCloseComplete FromServer[*pgproto3.CloseComplete]

func (*ServerExtendedQueryCloseComplete) ExtendedQuery()                    {}
func (t *ServerExtendedQueryCloseComplete) PgwireMessage() pgproto3.Message { return t.Parse() }
func (t *ServerExtendedQueryCloseComplete) Server() pgproto3.BackendMessage { return t.Parse() }
func (m *ServerExtendedQueryCloseComplete) Parse() *pgproto3.CloseComplete {
	return (*FromServer[*pgproto3.CloseComplete])(m).Parse()
}

// Retain returns a copy of this message with retained source bytes.
// Use this when the message must outlive the current iteration.
func (m ServerExtendedQueryCloseComplete) Retain() ServerExtendedQueryCloseComplete {
	src, parsed, isParsed := (*FromServer[*pgproto3.CloseComplete])(&m).retainFields()
	return ServerExtendedQueryCloseComplete{source: src, parsed: parsed, isParsed: isParsed}
}

// ToServerExtendedQuery converts a pgproto3.BackendMessage to a ServerExtendedQuery if it matches one of the known types.
// Note: This allocates. For zero-allocation iteration, use Cursor.AsServer().
func ToServerExtendedQuery(msg pgproto3.BackendMessage) (ServerExtendedQuery, bool) {
	switch m := msg.(type) {
	case *pgproto3.ParseComplete:
		return (*ServerExtendedQueryParseComplete)(ServerParsed(m)), true
	case *pgproto3.BindComplete:
		return (*ServerExtendedQueryBindComplete)(ServerParsed(m)), true
	case *pgproto3.ParameterDescription:
		return (*ServerExtendedQueryParameterDescription)(ServerParsed(m)), true
	case *pgproto3.RowDescription:
		return (*ServerExtendedQueryRowDescription)(ServerParsed(m)), true
	case *pgproto3.NoData:
		return (*ServerExtendedQueryNoData)(ServerParsed(m)), true
	case *pgproto3.PortalSuspended:
		return (*ServerExtendedQueryPortalSuspended)(ServerParsed(m)), true
	case *pgproto3.CloseComplete:
		return (*ServerExtendedQueryCloseComplete)(ServerParsed(m)), true
	}
	return nil, false
}

// ServerExtendedQueryHandlers provides type-safe handlers for each ServerExtendedQuery variant.
type ServerExtendedQueryHandlers[T any] struct {
	ParseComplete        func(msg *ServerExtendedQueryParseComplete) (T, error)
	BindComplete         func(msg *ServerExtendedQueryBindComplete) (T, error)
	ParameterDescription func(msg *ServerExtendedQueryParameterDescription) (T, error)
	RowDescription       func(msg *ServerExtendedQueryRowDescription) (T, error)
	NoData               func(msg *ServerExtendedQueryNoData) (T, error)
	PortalSuspended      func(msg *ServerExtendedQueryPortalSuspended) (T, error)
	CloseComplete        func(msg *ServerExtendedQueryCloseComplete) (T, error)
}

// HandleDefault dispatches to the appropriate handler, or calls defaultHandler if the handler is nil.
func (h ServerExtendedQueryHandlers[T]) HandleDefault(msg ServerExtendedQuery, defaultHandler func(msg ServerExtendedQuery) (T, error)) (r T, err error) {
	switch msg := msg.(type) {
	case *ServerExtendedQueryParseComplete:
		if h.ParseComplete != nil {
			return h.ParseComplete(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ServerExtendedQueryBindComplete:
		if h.BindComplete != nil {
			return h.BindComplete(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ServerExtendedQueryParameterDescription:
		if h.ParameterDescription != nil {
			return h.ParameterDescription(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ServerExtendedQueryRowDescription:
		if h.RowDescription != nil {
			return h.RowDescription(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ServerExtendedQueryNoData:
		if h.NoData != nil {
			return h.NoData(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ServerExtendedQueryPortalSuspended:
		if h.PortalSuspended != nil {
			return h.PortalSuspended(msg)
		} else {
			return defaultHandler(msg)
		}
	case *ServerExtendedQueryCloseComplete:
		if h.CloseComplete != nil {
			return h.CloseComplete(msg)
		} else {
			return defaultHandler(msg)
		}
	}
	err = fmt.Errorf("unknown server extendedquery message: %T", msg)
	return
}

// Handle dispatches to the appropriate handler, or panics if the handler is nil.
func (h ServerExtendedQueryHandlers[T]) Handle(msg ServerExtendedQuery) (T, error) {
	return h.HandleDefault(msg, func(msg ServerExtendedQuery) (T, error) {
		panic(fmt.Sprintf("no handler defined for server extendedquery message: %T", msg))
	})
}
